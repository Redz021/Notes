# HTTP状态码

## GET

- 200（OK） - 表示已在响应中发出

- 204（无内容） - 资源有空表示
- 301（Moved Permanently） - 资源的URI已被更新
- 303（See Other） - 其他（如，负载均衡）
- 304（not modified）- 资源未更改（缓存）
- 400 （bad request）- 指代坏请求（如，参数错误）
- 404 （not found）- 资源不存在
- 406 （not acceptable）- 服务端不支持所需表示
- 500 （internal server error）- 通用错误响应
- 503 （Service Unavailable）- 服务端当前无法处理请求

## POST

- 200（OK）- 如果现有资源已被更改

- 201（created）- 如果新资源被创建
- 202（accepted）- 已接受处理请求但尚未完成（异步处理）
- 301（Moved Permanently）- 资源的URI被更新
- 303（See Other）- 其他（如，负载均衡）
- 400（bad request）- 指代坏请求
- 404 （not found）- 资源不存在
- 406 （not acceptable）- 服务端不支持所需表示
- 409 （conflict）- 通用冲突
- 412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突）
- 415 （unsupported media type）- 接受到的表示不受支持
- 500 （internal server error）- 通用错误响应
- 503 （Service Unavailable）- 服务当前无法处理请求

## PUT

- 200 （OK）- 如果已存在资源被更改

- 201 （created）- 如果新资源被创建
- 301（Moved Permanently）- 资源的URI已更改
- 303 （See Other）- 其他（如，负载均衡）
- 400 （bad request）- 指代坏请求
- 404 （not found）- 资源不存在
- 406 （not acceptable）- 服务端不支持所需表示
- 409 （conflict）- 通用冲突
- 412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突）
- 415 （unsupported media type）- 接受到的表示不受支持
- 500 （internal server error）- 通用错误响应
- 503 （Service Unavailable）- 服务当前无法处理请求

## DELETE

- 200 （OK）- 资源已被删除

- 301 （Moved Permanently）- 资源的URI已更改
- 303 （See Other）- 其他，如负载均衡
- 400 （bad request）- 指代坏请求
- 404 （not found）- 资源不存在
- 409 （conflict）- 通用冲突
- 500 （internal server error）- 通用错误响应
- 503 （Service Unavailable）- 服务端当前无法处理请求

# 缓存

## HTTP缓存

当客户端向服务器请求资源时，会**先检查浏览器缓存**，如果浏览器有当前请求资源的副本，则直接从浏览器缓存中提取资源。

常见的HTTP缓存**只能缓存GET请求响应的资源**。第一次请求时，服务器返回资源，在response header中回传资源的缓存参数；第二次请求时，浏览器判断这些请求参数，命中强缓存就直接200，否则将请求参数加到request header中传给服务器，若命中协商缓存则返回304，否则返回新的数据。

### 强制缓存

利用响应头中的Expires或Cache-Control来控制。

**Expires**：缓存过期时间，用来指定资源到期的时间，是服务端具体的时间点。

绝对时间

**Cache-Control**：相对时间，与Expires同时启用时Cache-Control优先级较高。

### 协商缓存

若未命中强缓存，则浏览器会将请求发送至服务器，服务器根据http头信息中的Last-Modify/If-Modify-Since或ETag/If-None-Match来判断是否命中协商缓存。如果命中，则http返回码为304，浏览器从缓存中加载资源。

**Last-Modify/If-Modify-Since**

浏览器第一次请求一个资源的时候，服务器返回的header中会加上Last-Modify，Last-Modify是一个时间，表示该资源的最后修改时间。

当浏览器再次请求该资源时，发送的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。

如果命中缓存，则返回http304，并且不会返回资源内容，并且不会返回Last-Modify。

由于对比的服务端时间，所以客户端与服务端时间差距不会导致问题。但是有时候通过最后修改时间来判断资源是否修改还是不太准确（资源变化了最后修改时间也可以一致）。于是出现了ETag/If-None-Match。

**ETag/If-None-Match**

与Last-Modify/If-Modify-Since不同的是，Etag/If-None-Match返回的是一个校验码（ETag: entity tag）。ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化*。ETag值的变更则说明资源状态已经被修改。服务器根据浏览器上发送的If-None-Match值来判断是否命中缓存。

## 总结

例如：

1. 浏览器第一次访问服务器资源/index.html

   在浏览器中并没有缓存文件，直接向服务器发送请求，服务器返回200 ok，body中返回index.html，并设置缓存过期时间、文件修改时间、根据index计算出的Etag

   浏览器将index.html路径的请求缓存到本地

2. 浏览器再次访问/index.html

   由于本地已经有了此路径的缓存文件，所以这一次不直接向服务器发送请求，首先进行缓存过期判断，根据缓存过期时间判断缓存是否过期

   * 若未过期：不向服务器发送请求，直接使用缓存中的结果，此时在浏览器控制台可以看到200 ok(from cache)，此时的情况就是完全使用缓存，浏览器和服务器之间无交互(**强制缓存**)

   * 若过期：向服务器发送请求，此时请求中会带上之前设置的Etag和文件修改时间，之后进行资源更新判断。

     服务器根据浏览器传过来的文件修改时间**If-Modify-since**，判断自浏览器上一次请求之后，文件是否被修改

     根据**Etag**判断文件内容自上一次请求之后是否发生变化

     1. 若两种判断结论均为没有被修改，则服务器不返回请求的内容，返回**304 Not Modified**，此时浏览器从本地缓存中获取index.html(**协商缓存**)
     2. 若有一个判断为文件发生了变化，则受理请求，**过程同第一次访问**

浏览器第一次请求：

![img](https://images2018.cnblogs.com/blog/940884/201804/940884-20180423141945261-83532090.png)

 

浏览器再次请求时：

[![img](https://images2018.cnblogs.com/blog/940884/201804/940884-20180423141951735-912699213.png)](http://jbcdn2.b0.upaiyun.com/2016/07/c55ff974d09c5b729c795cb7fe7d5950.png)

# GET和POST的区别

| GET                                  | POST                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| 参数依靠url附带query                 | 参数来自表单提交，数据编码到请求体body中，url中也可传递参数  |
| 大多数浏览器限制URL长度一般不超过2KB | 理论上不受限制，服务器可能会限制                             |
| 数据在URL中，安全性较差              | 数据在请求体中，较GET而言安全性较好                          |
| 请求产生一个数据包，服务器200        | 产生两个数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok |
|                                      |                                                              |

# OSI七层模型

## 物理层

物理线路、光纤、中继器、集线器、双绞线

* 管理通信设备和网络媒体之间的互联互通。传输比特流。

## 数据链路层

以太网、网卡、交换机、PPTP、L2TP、ARP、ATMP

**提供访问介质和链路管理**

* 接收来自物理层的比特流数据，封装成帧，传送到网络层；

* 将网络层的数据帧拆分为比特流形式的数据转发到物理层；

* 负责建立和管理节点之间的链路，通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。

## 网络层

IP、ICMP、RIP、IGMP、OSPF

**IP选址及路由选择**

* 通过路由选择算法，为报文或通信子网选择最适合的路径。
* 控制数据链路层与传输层之间的信息转发，建立、维持和终止网络的链接。
* 数据帧在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进出路由等控制，将信息从一个网络设备传送到另一个网络设备。

## 传输层

TCP、UDP

**数据通信**

建立主机端到端的链接，为会话层和网络层提供端到端可靠的和透明的数据传输服务，确保数据能完整的传输到网络层。

## 会话层

SSL、TLS、DAP、LDAP

**创建、管理和维护会话**

接收来自传输层的数据，负责建立、管理和终止表示层实体之间的通信会话，支持它们之间的数据交换。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。

## 表示层

LPP、NBSSP

**数据编码、格式转换、数据加密**

提供各种用于应用层数据的编码和转换功能，确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。

## 应用层

HTTP(S)、FTP、SMTP、POP3、TELNET、NNTP、IMAP4、FINGER

**为应用程序或用户提供各种请求服务**

OSI参考模型最高层，也是最靠近用户的一层，为计算机用户，各种应用程序以及网络提供接口，也为用户直接提供各种网络服务。

# HTTP

| 版本 | 内容                                                         |
| ---- | ------------------------------------------------------------ |
| 0.9  | 不涉及数据包传输，规定客户端和服务器之间通信格式，只能GET请求。 |
| 1.0  | 传输内容格式不限制，增加PUT、PATCH、HEAD、OPTIONS、DELETE命令。 |
| 1.1  | 持久连接（长连接）、节约带宽、HOST域、管道机制、分块传输编码。 |
| 2.0  | 多路复用、服务器推送、头信息压缩、二进制协议等。             |

## HTTP特点

1. 无状态：协议对客户端没有状态存储，对事物处理没有记忆能力，比如访问一个网站需要反复登录。

   针对无状态的一些解决策略：

   * Cookie/Session技术。
   * HTTP1.1持久连接(keep-alive)方法，只要任意一端没有明确提出断开连接，则保持TCP连接状态，在请求首部字段中的Connection: keep-alive即为表明使用了持久连接。

2. 无连接：1.1之前，由于无状态特点，每次请求需要通过TCP三次握手四次挥手，和服务器重新建立连接。比如某个客户端在短时间内多次请求同一个资源，服务器并不能区别是否已经响应过用户的请求，所以每次需要重新响应请求，需要消耗不必要的时间和流量。

3. 基于请求和响应：基本的特性，由客户端发起请求，服务端响应。

4. 简单快速，灵活。

5. 通信使用明文，请求和响应不会对通信方进行确认，无法保证数据完整性。

## HTTPS特点

基于HTTP协议，通过SSL或TLS提供加密处理数据、验证对方身份以及数据完整性保护。

1. 内容加密：采用混合加密技术，中间人无法直接查看明文内容。
2. 验证身份：通过证书认证客户端访问的是自己的服务器。
3. 保护数据完整性：防止传输的过程中被中间人冒充或篡改。

原文 使用哈希 得到摘要 使用发送方私钥加密 得到加密后的数字签名

原文 经过密钥加密 得到密文

密钥 经过接收方公钥加密 得到加密后的密钥

拼接 发送

拆解出数字签名 使用发送方公钥解密 得到摘要

加密密钥 使用接收方私钥解密 得到原密钥

原密钥解密密文 得到原文

原文经过哈希 得到摘要 与之前的摘要对比

# TCP

## 三次握手

1. 将TCP首部的控制位中的SYN置1，表示希望建立连接。

   发送传输序号seq = X，seq为随机值，表示传输数据时第一个数据字节的序号是x。

   发送后客户端进入SYN_SEND状态。

2. 首部中SYN置1，ACK置1。

   seq = Y

   ack = 客户端发来的seq+1，表示希望下次的数据从X+1的位置开始。

   发送后服务端进入SYN_RCVD状态。

3. 标志位ACK置1，SYN不再需要，置0。

   seq = X+1，为第二次握手接收到的ack

   ack = Y+1

   发送后客户端进入ESTABLISHED状态。

   服务端接收到数据包后进入ESTABLISHED状态，TCP三次握手结束。

## 四次挥手

1. 客户端向服务端

   FIN置1，ACK置1

   seq = X，ack = Z

   发送后进入FIN_WAIT阶段，此时无法再次发送消息，只能处理关闭相关信息。

2. 服务端向客户端

   ACK置1

   seq = Z，ack = X+1

   服务端进入CLOSE_WAIT阶段，等待关闭，通知应用发送剩余数据，处理现场信息，关闭相应资源。

   客户端结束FIN-WAIT-1阶段，进入FIN-WAIT-2阶段。

3. 服务端向客户端

   FIN置1，ACK置1，表示准备好释放连接

   seq = Y，ack = X+1

   服务端结束CLOSE-WAIT阶段，进入LAST-ACK阶段。停止向客户端发送数据，但依然接收客户端发来的数据。

4. 客户端向服务端

   ACK置1，表示接收到服务器准备释放连接的信号

   seq = X+1，ack = Y+1

   客户端结束FIN-WAIT-2状态，进入TIME-WAIT状态，等待2MSL后结束，进入CLOSED阶段。

## TCP如何控制可靠传输？

### 校验和

发送的数据包的二进制相加然后取反，目的是检测数据在传输过程中的任何变化，如果收到的校验和有差错，TCP将丢弃这个报文段和不确认收到此报文段

### 确认应答+序列号

TCP给发送的每一个报进行编号，接收方对数据包进行排序，把有序数据传给应用层

### 超时重传

TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段，如果不能及时收到一个确认，将重发这个报文段

### 流量控制

TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议

接收方有即时窗口（滑动窗口），随ACK报文发送

### 拥塞控制

当网络拥塞时，减少数据的发送。发送方有拥塞窗口，发送数据前比对接收方发过来的即时窗口，取小。

慢启动、拥塞避免、拥塞发送、快速恢复

# TCP UDP区别

| TCP                                    | UDP                                          |
| -------------------------------------- | -------------------------------------------- |
| 面向连接                               | 无连接                                       |
| 可靠传输，使用流量控制和拥塞控制       | 不可靠传输，不使用流量控制和拥塞控制         |
| 一对一通信                             | 一对一，一对多，多对一，多对多               |
| 面向字节流                             | 面向报文                                     |
| 首部最小20字节，最大60字节             | 首部开销小，仅8字节                          |
| 适用于要求可靠传输的应用，例如文件传输 | 适用于实时应用，例如IP电话、视频会议、直播等 |

# 浏览器的同源策略

同源策略是一个重要的安全策略，它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助组个恶意文档，减少可能被攻击的媒介。

## 同源的定义

如果两个URL的**协议、端口、主机名**都相同的话，则这两个URL同源。

## 源的更改

脚本可以将`document.domain`的值设置为当前域或其当前域的父域。

## 如何允许跨源访问

使用CORS

**CORS**——跨域资源共享

浏览器一旦发现ajax请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但是用户不会有感觉

例：浏览器发现这次跨源请求是简单请求，就在头信息中添加一个`Origin`字段，说明本次请求来自哪个源。服务器根据这个值决定是否同意这次请求。

如果`Origin`指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现这个回应的头信息没有包含`Access-Control-Allow-Origin`字段，则抛出错误；

如果`Origin`指定的源在许可范围内，服务器返回的响应会多出几个头信息字段：

**Access-Control-Allow-Origin**：必须，值为请求时Origin字段的值或*，表示接收任意域名的请求

**Access-Control-Allow-Credentials**：可选，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求中。**true**表示服务器明确许可Cookie可以包含在请求中，一起发给服务器。若不允许，则直接删除该字段

......

http://www.ruanyifeng.com/blog/2016/04/cors.html

## 如何阻止跨源请求

阻止跨域写操作，只要检测请求中的一个不可推测的标记(**CSRF token**)即可，这个标记被称为Cross-Site Request Forgery(CSRF)标记，必须使用这个标记来阻止页面的跨站读操作。

阻止资源的跨站读取，需要保证资源是不可嵌入的。

阻止跨站嵌入，需要确保资源不能通过上述的可嵌入资源格式使用。

## jsonp处理跨域