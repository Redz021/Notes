# BFC IFC GFC FFC

CSS2.1中只有BFC，IFC；CSS3中有GFC，FFC

## BFC

块级格式化上下文

页面上一块隔离的渲染区域，容器内的子元素不会在布局上影响到外面的元素，反之亦然

### **触发方式**

* float不为none
* overflow不为visible
* position不为relative或static
* display为table-cell, table-caption, inline-block, flex

### **作用**

常见的多栏布局，结合块级元素浮动，内部元素在一个相对隔离的环境中运行

### 特性

* 同一个BFC下margin会发生折叠

  可将其中一个元素放在独立的BFC中

* BFC可以包含浮动元素

  可以解决高度塌陷问题

* BFC可以阻止元素被浮动元素覆盖

## IFC

内联格式化上下文

IFC的line-box高度由包含的行内元素中最高的实际高度计算而来 不受竖直方向padding和margin的影响

IFC中line-box一般紧贴左右两侧，会受到float元素扰乱，float元素会位于IFC和line-box之间，使得line-box宽度缩短。同一IFC下的多个line-box高度会不同

IFC中不能存在块级元素，插入块级元素会产生两个匿名块与插入的块级元素分开，即产生两个IFC，每个IFC对外表现为块级元素，与插入的块级元素垂直排列

### 作用

* 水平居中：可设置inline-block在外层产生IFC，通过text-align将其水平居中
* 垂直居中：创建一个IFC，用其中一个元素撑起父元素的高度，设置vertical-align: middle，其他行内元素可在此父元素下垂直居中

## GFC

网格布局格式化上下文

当元素设置display: grid时，元素会获得一个独立的渲染区域，可以通过在**网格容器(grid container)**上定义**网格定义行(grid definition rows)**和**网格定义列(grid definition columns)**属性在**网格项目(grid item)**上定义**网格行(grid row)**和**网格列(grid column)**为每一个网格项目定义位置和空间

### 作用

与table相比，grid布局会有更加丰富的属性来控制行列，控制对齐和更为精细的渲染语义和控制

## FFC

自适应格式化上下文

display为flex或inline-flex时会生成自适应容器

容器中每一个子元素都是一个伸缩项目，伸缩项目数量随意

# div水平居中、垂直居中方法

## absolute+transform

```css
#method1 {
            background: #666;
            position: relative;
            width: 500px;
            height: 400px;
        }
        
#method1 div {
            background: #333;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            height: 300px;
        }
```

![image-20201002104950034](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20201002104950034.png)

## absolute+margin

确定当前div宽度，margin值为当前div宽度一半的负值

```css
#method2 div {
            width: 300px;
            height: 300px;
            background: #333;
            position: absolute;
            left: 50%;
            top: 50%;
            margin-left: -150px;
            margin-top: -150px;
        }
```

效果同上

***

left right top bottom均设置为0，margin设置auto

优点：无需了解容器宽高

```css
#method3 div {
            width: 300px;
            height: 300px;
            background: #333;
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            bottom: 0;
            margin: auto;
        }
```

## flex

使用align-items和justify-contents或者直接设置margin: auto

```css
#method4 {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 500px;
            width: 700px;
            background: #6af;
        }
#method4 div {
            width: 300px;
            height: 300px;
            background: #666;
        }
```

## table-cell

display: table-cell配合vertical-align: middle和text-align: center

**内部子元素须设置为inline-block**

```css
#method5 {
            display: table-cell;
            vertical-align: middle;
            text-align: center;
            width: 500px;
            height: 400px;
            background: chocolate;
        }
#method5 div {
            padding: 5px;
            border: 1px solid black;
            display: inline-block;
        }
```

## calc()

```css
#method6 {
            position: relative;
            width: 500px;
            height: 400px;
            background: chocolate;
        }
#method6 div {
            position: absolute;
            width: 300px;
            height: 300px;
            left: calc((500px - 300px)/2);
            top: calc((400px - 300px)/2);
            background: white;
        }
```

# display visibility opacity

|                    | DOM结构                                  | 事件监听            | 性能                               | 继承                                                    | transition                         |
| ------------------ | ---------------------------------------- | ------------------- | ---------------------------------- | ------------------------------------------------------- | ---------------------------------- |
| display: none      | 浏览器不渲染，不占用空间                 | 无法进行DOM事件监听 | 动态改变此属性会引起重排，性能较差 | 不会被子元素继承，因为子元素也不会被渲染                | transition不支持display            |
| visibility: hidden | 元素被隐藏，但是被渲染不会消失，占用空间 | 无法进行DOM事件监听 | 动态改变此属性会引起重绘，性能较好 | 会被子元素继承，子元素可设置visibility: visible取消隐藏 | visibility会立即显示，隐藏时会延时 |
| opacity: 0         | 透明度0%，元素隐藏，占用空间             | 可以进行DOM事件监听 | 提升为合成层，不触发重绘，性能较好 | 会被子元素继承，子元素无法使用opacity: 1取消隐藏        | opacity可以延时显示和隐藏          |

# 覆盖元素宽度

例：在不改变当前代码情况下，使这张图片宽度变为300px

```html
<img src="1.jpg" style="width: 480px!important;"/>
```

解答：

1. **CSS方法**

   ```html
   <img src="1.jpg" style="width: 480px!important;max-width: 300px;"/>
   <img src="1.jpg" style="width: 480px!important;transform: scale(0.625, 1);"/>
   <img src="1.jpg" style="width: 480px!important;width: 300px!important;"/>
   ```

2. **JS方法**

   ```javascript
   document.getElementByTagName("img")[0].setAttribute("style","width:300px!important;");
   ```

# Retina屏幕1px边框问题

CSS中的1px并不等于移动设备的1px，不同设备有不同的像素密度

`window`对象中有一个`devicePixelRatio`属性，表示CSS中的像素和设备的像素比

> MDN定义：`window`接口的`devicePixelRatio`返回当前显示设备的*物理像素*分辨率与*CSS像素分辨率*之比。

简单来说，他告诉浏览器应使用多少屏幕实际像素来绘制单个CSS像素。

**解决办法：**

## 0.5px边框

可以通过JavaScript检测浏览器能否处理0.5px的边框，如果可以则给HTML标签元素添加class

```javascript
if(window.devicePixelRatio && devicePixelRatio >= 2){
	var testElem = document.createElement('div');
	testElem.style.border = '.5px solid transparent';
	document.body.appendChild(testElem);
	if(testElem.offsetHeight == 1){
		document.querySelector('html').classList.add('hairlines');
	}
	document.body.removeChild(testElem);
}
```

```css
div{
	border: 1px solid black;
}
.hairlines div{
	border-width: 0.5px;
}
```

## border-image

使用高2px的边框图片，一半透明一半有色，压缩为高1px的边框

修改颜色麻烦，需要更换图片

圆角需要特殊处理，并且边缘会模糊

## background-image

准备一张符合要求的图片

```css
.background-image-1px{
	background: url(../image/line.jpg) repeat-x left bottom;
	background-size: 100% 1px;
}
```

缺点同上

## 多背景渐变实现

与background-image类似，只是将图片替换为CSS3渐变，设置1px的渐变背景，50%有颜色，50%透明

```css
.background-gradient-1px{
	background: linear-gradient(180deg, black, black 50%, transparent 50%) top left / 100% 1px no-repeat,
				linear-gradient(90deg, black, black 50%, transparent 50%) top right / 1px 100% no-repeat,
				linear-gradient(0deg, black, black 50%, transparent 50%) bottom right / 100% 1px no-repeat,
				linear-gradient(-90deg, black, black 50%, transparent 50%) bottom left / 1px 100% no-repeat;
}
/*或者*/
.background-gradient-1px{
	background: -webkit-gradient(linear, left top, left bottom, color-stop(.5, transparent), color-stop(.5, #c8c7cc), 							to(#c8c7cc)) left bottom repeat-x;
	background-size: 100% 1px;
}
```

## box-shadow

inset内阴影

```css
.box-shadow-1px{
	box-shadow: inset 0px -1px 1px -1px #c8c7cc;
}
```

## viewport+rem(最常用)

同时通过设置对应viewport的rem基准值

这种兼容方案相对比较完美，适合新项目，老项目修改成本过高

## 伪类+transform

原理：把原来元素的border去掉，然后利用`:before`或者`:after`重做border，并transform的scale缩小一半，原先的元素相对定位，新做的border绝对定位

**单条边框**

```css
.scale-1px{
	position: relative;
	border: none;
}
.scale-1px:after{
	content: '';
	position: absolute;
	bottom: 0;
	background: #000;
	width: 100%;
	height: 1px;
	transform: scaleY(0.5);
	transform-origin: 0 0;
}
```

# ['1','2','3'].map(parseInt)

```javascript
['10','10','10','10','10'].map(parseInt);
//[10,NaN,2,3,4]
```

> `parseInt(string, radix)`解析一个字符串并返回一个指定基数的十进制整数，`radix`是2-36之间的整数，表示被解析字符串的基数。

```javascript
['1','2','3'].map(parseInt);
```

对于每个迭代`map`，`parseInt()`传递两个参数：**字符串**和**基数**，所以实际执行的代码是

```javascript
['1','2','3'].map((item, index) => {
    return parseInt(item, index);
});
```

即返回值为

```javascript
parseInt('1', 0);//1
parseInt('2', 1);//NaN
parseInt('3', 2);//NaN 3不是二进制
```

# 函数防抖 函数节流

## setTimeout()

`setTimeout()`方法设置一个定时器，该定时器在定时器到期后执行一个函数或指定的一段代码。

返回值`timeoutID`是一个正整数，表示定时器的编号。这个值可以传递给`clearTimeout()`来取消该定时器。

例：在一个网页中运行如下脚本，并且点击一次页面。一秒钟后你会看见弹出一条信息。如果你在一秒内不停点击页面，弹出框将不再出现。

```javascript
var alarm = {
  remind: function(aMessage) {
    alert(aMessage);
    delete this.timeoutID;
  },

  setup: function() {
    this.cancel();
    var self = this;
    this.timeoutID = window.setTimeout(function(msg) {self.remind(msg);}, 1000, "Wake up!");
  },

  cancel: function() {
    if(typeof this.timeoutID == "number") {
      window.clearTimeout(this.timeoutID);
      delete this.timeoutID;
    }
  }
};
window.onclick = function() { alarm.setup() };
```

## 概念

**函数防抖(debounce)：**触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间。

**函数节流(throttle)：**高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率。

**函数节流(throttle)**与**函数防抖(debounce)**都是为了限制函数的执行频次，以优化函数触发频率过高导致的响应速度跟不上触发频率，出现延迟，假死或卡顿的现象。

## 函数防抖

- 实现方式：每次触发事件时设置一个延迟调用方法，并且取消之前的延时调用方法
- 缺点：如果事件在规定的时间间隔内被不断的触发，则调用方法会被不断的延迟

```javascript
//防抖debounce代码：
function debounce(fn,delay) {
    var timeout = null; // 创建一个标记用来存放定时器的返回值
    return function (e) {
        // 每当用户输入的时候把前一个 setTimeout clear 掉
        clearTimeout(timeout); 
        // 然后又创建一个新的 setTimeout, 这样就能保证interval 间隔内如果时间持续触发，就不会执行 fn 函数
        timeout = setTimeout(() => {
            fn.apply(this, arguments);
        }, delay);
    };
}
// 处理函数
function handle() {
    console.log('防抖：', Math.random());
}
        
//滚动事件
window.addEventListener('scroll', debounce(handle,500));
```

## 函数节流

- 实现方式：每次触发事件时，如果当前有等待执行的延时函数，则直接return

```javascript
//节流throttle代码：
function throttle(fn,delay) {
    let canRun = true; // 通过闭包保存一个标记
    return function () {
         // 在函数开头判断标记是否为true，不为true则return
        if (!canRun) return;
         // 立即设置为false
        canRun = false;
        // 将外部传入的函数的执行放在setTimeout中
        setTimeout(() => { 
        // 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。
        // 当定时器没有执行的时候标记永远是false，在开头被return掉
            fn.apply(this, arguments);
            canRun = true;
        }, delay);
    };
}
 
function sayHi(e) {
    console.log('节流：', e.target.innerWidth, e.target.innerHeight);
}
window.addEventListener('resize', throttle(sayHi,500));
```

> 浏览器在处理setTimeout和setInterval时，有最小时间间隔。
> setTimeout的最短时间间隔是4毫秒；
> setInterval的最短间隔时间是10毫秒，也就是说，小于10毫秒的时间间隔会被调整到10毫秒。
> 事实上，未优化时，scroll事件频繁触发的时间间隔也是这个最小时间间隔。
> 也就是说，当我们在debounce函数中的间隔事件设置不恰当（小于这个最小时间间隔），会使debounce无效。

**总结：**
**函数防抖**：将多次操作合并为一次操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。

**函数节流**：使得一定时间内只触发一次函数。原理是通过判断是否有延迟调用函数未执行。

**区别**： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。

# Set Map WeakSet WeakMap

## Set

* 成员唯一，无序，不重复
* [value, value] 键，值相等，或者说没有键
* 可以遍历，方法有add，delete，has

[MDN定义](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set)

## WeakSet

* 成员都是对象
* 成员都是弱引用，可以被垃圾回收机制回收，可以用来保存节点，不容易造成内存泄漏
* 不能遍历，方法有add，delete，has

[MDN定义](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakSet)

## Map

* 本质上是键值对的集合，类似集合
* 可以遍历，方法很多，可以与各种数据格式转换

[MDN定义](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map)

## WeakMap

* 只接受对象作为键名，null除外，不接受其他类型
* 键名是弱引用，键值任意，键名指向的对象可以被回收，此时键名无效
* 不能遍历，方法有get，set，has，delete

[MDN定义](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap)

# 如何判断数组

## Object.prototype.toString.call()

Object中的`toString`方法返回`[object type]`，type为对象的类型。除了Object类型以外的对象使用`toString`方法时会直接返回内容的字符串，所以需要使用call或apply方法改变`toString`方法的执行上下文

```javascript
const an = ['hello', 'an'];
an.toString();//'hello, an'
Object.prototype.toString.call(an);//'[object Array]'
```

这种方法对于所有基本数据类型都能判断，包括null和undefined

## instanceof

通过判断对象的原型链中是不是能找到类型的prototype

```javascript
[] instanceof Array;//true
```

## Array.isArray()

ES5新增

用于判断对象是否为数组

不存在Array.isArray()时可使用Object.prototype.toString.call()

```javascript
if(!Array.isArray){
    Array.isArray = function(arg){
        return Object.prototype.toString.call(arg) === '[object Array]'; 
    }
}
```

# ES5 ES6定义对象的区别

## `class`声明提升，但不会初始化赋值，`foo`进入暂时性死区，类似于`let`,`const`声明变量

```javascript
const bar = new Bar();//ok
function Bar(){
    this.bar = 42;
}
const foo = new Foo();//ReferenceError: Foo is not defined
class Foo{
    constructor(){
        this.foo = 42;
    }
}
```

## `class`声明内部会启用严格模式

```javascript
//引用一个未声明的变量
function Bar(){
    baz = 42;//ok
}
const bar = new Bar();

class Foo{
    constructor(){
        fol = 42;//ReferenceError: fol is not defined
    }
}
const foo = new Foo();
```

## `class`中的所有方法都是不可枚举的

```javascript
function Bar(){
    this.bar = 42;
}
Bar.answer = function(){
    return 42;
};
Bar.prototype.print = function(){
    console.log(this.bar);
};
const barKeys = Object.keys(bar);//['answer']
const barProtoKeys = Object.keys(Bar.prototype);//['print']

class Foo{
    constructor(){
 		this.foo = 42;
    }
    static answer(){
        return 42;
    }
    print(){
        console.log(this.foo);
    }
}
const fooKeys = Object.keys(Foo);//[]
const fooProtoKeys = Object.keys(Foo.prototype);//[]
```

## `class`中的所有方法都没有原型对象prototype，不能使用`new`来调用

```javascript
function Bar(){
    this.bar = 42;
}
Bar.prototype.print = function(){
    console.log(this.bar);
};
const bar = new Bar();
const barPrint = new bar.print();//ok

class Foo{
    constructor(){
        this.foo = 42;
    }
    print(){
        console.log(this.foo);
    }
}
const foo = new Foo();
const fooPrint = new foo.print();//TypeError: foo.print is not a constructor
```

## 必须使用`new`调用`class`

```javascript
function Bar(){
    this.bar = 42;
}
const bar = Bar();//ok

class Foo{
    constructor(){
        this.foo = 42;
    }
}
const foo = Foo();//TypeError: class constructor Foo cannot be invoked without 'new'
```

## `class`内部无法重写类名

```javascript
function Bar(){
    Bar = 'Baz';//ok
    this.bar = 42;
}
const bar = new Bar();
//Bar: 'Baz'
//bar: Bar{bar: 42}

class Foo{
    constructor(){
        this.foo = 42;
        Foo = 'Fol';//TypeError: Assignment to constant variable
    }
}
const foo = new Foo();
Foo = 'Fol'//ok
```

# 全局作用域中，用const和let声明的变量位置？

ES5中，顶层对象的属性和全局变量是等价的，var和function命令声明的全局变量自然也是顶层对象

```javascript
var a = 12;
function f(){};
console.log(window.a);//12
console.log(window.f);//f(){}
```

ES6规定，var和function声明的全局变量依旧是顶层对象的属性，但let、class、const声明的全局变量，不属于顶层对象的属性

```javascript
let aa = 1;
const bb = 2;
console.log(window.aa);//undefined
console.log(window.bb);//undefined
```

用let和const声明的全局变量并没有在全局对象中，只是一个块级作用域(Script)中

在定义变量的块级作用域中即可获取变量

```javascript
let aa = 1;
const bb = 2;
console.log(aa);//1
console.log(bb);//2
```

const和let会生成块级作用域，可以理解为

```js
let a = 10;
const b = 20;
//相当于：
(function(){
    var a = 10;
    var b = 20;
})()
```

# 浏览器兼容问题

## 原因

* 同一产品，版本越老bug越多
* 同一产品，版本越新功能越多
* 不同产品，不同标准，不同实现方式

## 处理思路

1. **要不要做**

* 产品的角度（产品的受众，受众的浏览器比例，效果优先还是基本功能优先）
* 成本的角度（有没有必要）

2. **做到什么程度**

* 让哪些浏览器支持哪些效果

3. **如何做**

* 根据兼容需求选择技术框架/库
* 根据兼容需求选择兼容工具（html5shiv.js, respond.js, css reset, normalize.css Modernizr）
* 条件注释，CSS Hack，js能力检测做一些修补
* 渐进增强（progressive enhancement）：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果，交互的等改进和追加功能达到更好的用户体验
* 优雅降级（graceful degraduation）：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容

# 性能优化

* 减少HTTP请求
* 减少DOM操作
* 避免不必要的重绘与重排
* 优化CSS选择器（从右向左匹配）
* CSS/JS minify，减少文件体积
* 开启gzip压缩
* 将css放到顶部，JavaScript放到尾部
* 压缩图片以及使用CSS sprite
* 使用CDN加速，适当进行文件缓存
* 合理控制cookie大小（每次请求都会包含cookie）

# 安全性问题

## XSS(Cross Site Scripting)

### 定义

跨站脚本攻击是指恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。
 xss漏洞通常是通过php的输出函数将javascript代码输出到html页面中，通过用户本地浏览器执行的，所以xss漏洞关键就是**寻找参数未过滤的输出函数**。
 常见的输出函数有： `echo printf print print_r sprintf die var-dump var_export`.

### 危害

- 挂马
- 盗取用户Cookie。
- DOS（拒绝服务）客户端浏览器。
- 钓鱼攻击，高级的钓鱼技巧。
- 删除目标文章、恶意篡改数据、嫁祸。
- 劫持用户Web行为，甚至进一步渗透内网。
- 爆发Web2.0蠕虫。
- 蠕虫式的DDoS攻击。
- 蠕虫式挂马攻击、刷广告、刷浏量、破坏网上数据
- 其他安全问题

[更多](https://blog.csdn.net/qw_xingzhe/article/details/80712840)

### 攻击方式

常用的XSS攻击手段和目的有：

1、盗用cookie，获取敏感信息。

2、利用植入Flash，通过crossdomain权限设置进一步获取更高权限；或者利用Java等得到类似的操作。

3、利用iframe、frame、XMLHttpRequest或上述Flash等方式，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作。

4、利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动。

5、在访问量极大的一些页面上的XSS可以攻击一些小型网站，实现DDoS攻击的效果。

### 防御

(1)基于特征的防御。XSS漏洞和著名的SQL注入漏洞一样，都是利用了Web页面的编写不完善，所以每一个漏洞所利用和针对的弱点。都不尽相同。这就给XSS漏洞防御带来了困难，不可能以单一特征来概括所有XSS攻击。

传统的XSS防御在进行攻击鉴别时多采用特征匹配方式，主要是针对“javascript”这个关键字进行检索，但是这种鉴别不够灵活，凡是提交的信息中各有“javascript”时，就被硬性的被判定为XSS攻击。

(2)基于代码修改的防御。Web页面开发者在编写程序时往往会出现一些失误和漏洞，XSS攻击正是利用了失误和漏洞，因此一种比较理想的方法就是通过优化Web应用开发来减少漏洞，避免被攻击：1)用户向服务器上提交的信息要对URL和附带的的HTTP头、POST数据等进行查询，对不是规定格式、长度的内容进行过滤。2)实现Session标记（session tokens）、CAPTCHA系统或者HTTP引用头检查，以防功能被第三方网站所执行。3)确认接收的的内容被妥善的规范化，仅包含最小的、安全的Tag（没有javascript），去掉任何对远程内容的引用（尤其是样式表和javascript），使用HTTP only的cookie。

当然，如上操作将会降低Web业务系统的可用性，用户仅能输入少量的制定字符，人与系统间的交互被降到极致，仅适用于信息发布型站点。并且考虑到很少有Web编码人员受过正规的安全培训，很难做到完全避免页面中的XSS漏洞。

(3)客户端分层防御策略。客户端跨站脚本攻击的分层防御策略是基于独立分配线程和分层防御策略的安全模型。它建立在客户端(浏览器)，这是它与其他模型最大的区别，之所以客户端安全性如此重要，客户端在接受服务器信息，选择性的执行相关内容。这样就可以使防御XSS攻击变得容易，该模型主要由三大部分组成：1)对每一个网页分配独立线程且分析资源消耗的“网页线程分析模块”；2)包含分层防御策略四个规则的用户输入分析模块；3)保存互联网上有关XSS恶意网站信息的XSS信息数据库。 [3] 

XSS攻击主要是由程序漏洞造成的，要完全防止XSS安全漏洞主要依靠程序员较高的编程能力和安全意识，当然安全的软件开发流程及其他一些编程安全原则也可以大大减少XSS安全漏洞的发生。这些防范XSS漏洞原则包括：

（1）不信任用户提交的任何内容，对所有用户提交内容进行可靠的输入验证，包括对URL、查询关键字、HTTP头、REFER、POST数据等，仅接受指定长度范围内、采用适当格式、采用所预期的字符的内容提交，对其他的一律过滤。尽量采用POST而非GET提交表单；对“<”，“>”，“；”，“””等字符做过滤；任何内容输出到页面之前都必须加以en-code，避免不小心把htmltag显示出来。

（2）实现Session 标记（session tokens）、CAPTCHA（验证码）系统或者HTTP引用头检查，以防功能被第三方网站所执行，对于用户提交信息的中的img等link，检查是否有重定向回本站、不是真的图片等可疑操作。

（3）cookie 防盗。避免直接在cookie中泄露用户隐私，例如email、密码，等等；通过使cookie和系统IP绑定来降低cookie泄露后的危险。这样攻击者得到的cookie没有实际价值，很难拿来直接进行重放攻击。

（4）确认接收的内容被妥善地规范化，仅包含最小的、安全的Tag（没有JavaScript），去掉任何对远程内容的引用（尤其是样式表和JavaScript），使用HTTPonly的cookie。

## CSRF/XSRF(Cross—Site Request Forgery)

### 概念

**CSRF跨站点请求伪造(Cross—Site Request Forgery)**，跟XSS攻击一样，存在巨大的危害性，你可以这样来理解：
    攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 如下：其中Web A为存在CSRF漏洞的网站，Web B为攻击者构建的恶意网站，User C为Web A网站的合法用户。

### 原理

1. 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；
2. 在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；
3. 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；
4. 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；
5. 浏览器在接收到这些攻击性代码后，根据网站 B 的请求，在用户不知情的情况下携带 Cookie 信息，向网站 A 发出请求。网站 A 并不知道该请求其实是由 B 发起的，所以会根据用户 C 的 Cookie 信息以 C 的权限处理该请求，导致来自网站 B 的恶意代码被执行。 

### 实例

​		受害者 Bob 在银行有一笔存款，通过对银行的网站发送请求 http://bank.example/withdraw?account=bob&amount=1000000&for=bob2 可以使 Bob 把 1000000 的存款转到 bob2 的账号下。通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该 session 的用户 Bob 已经成功登陆。

​		黑客 Mallory 自己在该银行也有账户，他知道上文中的 URL 可以把钱进行转帐操作。Mallory 可以自己发送一个请求给银行：http://bank.example/withdraw?account=bob&amount=1000000&for=Mallory。但是这个请求来自 Mallory 而非 Bob，他不能通过安全认证，因此该请求不会起作用。

​		这时，Mallory 想到使用 CSRF 的攻击方式，他先自己做一个网站，在网站中放入如下代码： src=”http://bank.example/withdraw?account=bob&amount=1000000&for=Mallory ”，并且通过广告等诱使 Bob 来访问他的网站。当 Bob 访问该网站时，上述 url 就会从 Bob 的浏览器发向银行，而这个请求会附带 Bob 浏览器中的 cookie 一起发向银行服务器。大多数情况下，该请求会失败，因为他要求 Bob 的认证信息。但是，如果 Bob 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，浏览器的 cookie 之中含有 Bob 的认证信息。这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 Bob 的账号转移到 Mallory 的账号，而 Bob 当时毫不知情。等以后 Bob 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 Mallory 则可以拿到钱后逍遥法外。 

### 检测

​		检测CSRF漏洞是一项比较繁琐的工作，最简单的方法就是抓取一个正常请求的数据包，去掉Referer字段后再重新提交，如果该提交还有效，那么基本上可以确定存在CSRF漏洞。

​    	随着对CSRF漏洞研究的不断深入，不断涌现出一些专门针对CSRF漏洞进行检测的工具，如CSRFTester，CSRF Request Builder等。

​    	以CSRFTester工具为例，CSRF漏洞检测工具的测试原理如下：使用CSRFTester进行测试时，首先需要抓取我们在浏览器中访问过的所有链接以及所有的表单等信息，然后通过在CSRFTester中修改相应的表单等信息，重新提交，这相当于一次伪造客户端请求。如果修改后的测试请求成功被网站服务器接受，则说明存在CSRF漏洞，当然此款工具也可以被用来进行CSRF攻击。

### 防御

目前防御 CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token 并验证；在 HTTP 头中自定义属性并验证。

* **验证 HTTP Referer 字段**

​		根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问 http://bank.example/withdraw?account=bob&amount=1000000&for=Mallory，用户必须先登陆 bank.example，然后通过点击页面上的按钮来触发转账事件。这时，该转帐请求的 Referer 值就会是转账按钮所在的页面的 URL，通常是以 bank.example 域名开头的地址。而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。

​    	这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。

​    	然而，这种方法并非万无一失。Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全。事实上，对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值。如果 bank.example 网站支持 IE6 浏览器，黑客完全可以把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行 CSRF 攻击。

​		即便是使用最新的浏览器，黑客无法篡改 Referer 值，这种方法仍然有问题。因为 Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心 Referer 值会把组织内网中的某些信息泄露到外网中。因此，用户自己可以设置浏览器使其在发送请求时不再提供 Referer。当他们正常访问银行网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。

* **在请求地址中添加 token 并验证**

​		CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。

​    	这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 http://url?csrftoken=tokenvalue。 而对于 POST 请求来说，要在 form 的最后加上 <input type="hidden" name="csrftoken" value="tokenvalue"/>，这样就把 token 以参数的形式加入请求了。但是，在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token。

​		该方法还有一个缺点是难以保证 token 本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上 token，黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。

* **在 HTTP 头中自定义属性并验证**

​		这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。

​		然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。

# 圣杯布局 双飞翼布局

## 什么是圣杯布局？

圣杯布局是为了讨论*三栏液态布局*的实现，最早的完美实现是由Matthew Levine在2006年写的一篇文章《In Search of the Holy Grail》，它主要讲述了网页中关于最佳圣杯的实现方法。

圣杯布局和双飞翼布局达到的效果基本相同，都是侧边两栏宽度固定，中间栏宽度自适应。 主要的不同之处就是在解决中间部分被挡住的问题时，采取的解决办法不一样。

* 圣杯布局是在父元素上设置了padding-left和padding-right，在给左右两边的内容设置position为relative，通过左移和右移来使得左右两边的内容得以很好的展现，

* 而双飞翼则是在center这个div中再加了一个div来放置内容，在给这个新的div设置margin-left和margin-right 。

圣杯布局有以下几点要求：

* 上部(header)和下部(footer)各自占领屏幕所有宽度
* 上下部之前的部分(container)是一个三栏布局
* 三栏布局两侧宽度不变，中间部分自动填充整个区域
* 中间部分的高度是三栏中最高的区域的高度

有两种实现的方法：浮动和flex

## 方法1：浮动

```html
<div class="header">
    <h4>header</h4>
</div>

<div class="container">
    <div class="middle">
        <h4>middle</h4>
        <p>middle-content</p>
    </div>
    <div class="left">
        <h4>left</h4>
        <p>left-content</p>
    </div>
    <div class="right">
        <h4>right</h4>
        <p>right-content</p>
    </div>
</div>

<div class="footer">
    <h4>footer</h4>
</div>
```

```css
.header, .footer{
    border: 1px solid #333;
    background: #ccc;
    text-align: center;
}
.footer{
    clear: both;
}
.container{
    padding: 0 220px 0 200px;
    overflow: hidden;
}
.left, .middle, .right{
    position: relative;
    float: left;
    min-height: 130px;
}
.middle{
    width: 100%;
    background: blue;
}
.left{
    margin-left: -100%;
    left: -200px;
    width: 200px;
    background: red;
}
.right{
    margin-left: -220px;
    right: -220px;
    width: 220px;
    background: green;
}
```

思路：

* 使header和footer横向撑满
* container中的三列设为浮动和相对定位(后面会用到)，middle放在最前面，footer清除浮动
* 三列的左右两列分别定宽200px和220px，中间部分middle设置100%撑满
* 因为浮动，middle会占据整个container，左右被挤下去
* 设置left的`margin-left: -100%;`让left回到上一行最左侧，但会把middle遮住，所以给外层的container设置`padding: 0 220px 0 200px;`给left空出位置

* 这时left并没有在最左侧，因为之前已经设置过相对定位，所以通过`left: -200px;`把left拉回最左侧
* 同样对于right区域，设置`margin-left: -220px;`把right拉回第一行，这时右侧空出了220px空间，所以最后设置`right: -220px;`把right拉到最右侧

## 方法2：flex弹性盒子

```css
.header, .footer{
    border: 1px solid #333;
    background: #ccc;
    text-align: center;
}
.container{
    display: flex;
}
.left{
    width: 200px;
    background: red;
}
.middle{
    flex: 1;
    background: blue;
}
.right{
    width: 220px;
    background: green;
}
```

思路：

* header和footer同上，footer不再需要清除浮动
* container中的left，middle，right依次排布即可，不用特意把middle放置到最前面
* 给container设置弹性布局`display: flex;`
* left和right定宽，middle设置`flex: 1;`

## 双飞翼布局

```html
<div class="header">
    <h4>header</h4>
</div>

<div class="container">
    <div class="middle">
        <div class="inner-middle">
            <h4>middle</h4>
        	<p>middle-content</p>
        </div>
    </div>
    <div class="left">
        <h4>left</h4>
        <p>left-content</p>
    </div>
    <div class="right">
        <h4>right</h4>
        <p>right-content</p>
    </div>
</div>

<div class="footer">
    <h4>footer</h4>
</div>
```



```css
.header, .footer{
    border: 1px solid #333;
    background: #ccc;
    text-align: center;
}
.footer{
    clear: both;
}
.container{
    overflow: hidden;
}
.left, .middle, .right{
    float: left;
    min-height: 130px;
}
.left{
    margin-left: -100%;
    width: 200px;
    background: red;
}
.right{
    margin-left: -220px;
    width: 220px;
    background: green;
}
.middle{
    width: 100%;
}
.inner-middle{
    margin-left: 200px;
    margin-right: 220px;
    min-height: 130px;
    background: blue;
}
```



# 跨域问题

同源策略

同源策略可以防止JavaScript发起跨域请求。源被定义为URI、主机名和端口号的组合。此策略可防止页面上的恶意脚本通过该页面的DOM访问另一个网页上的敏感数据

### 原因

浏览器同源策略导致了跨域

### 作用

用于隔离潜在恶意文件的重要安全机制

### 解决

* jsonp，允许script加载第三方资源
* 代理
* cors前后端协作设置响应头部，Access-Control-Allow-Origin："*"等头部信息
* iframe嵌套通讯，postmessage

# 事件绑定

* 嵌入DOM

  耦合高，不利于维护

```html
<button onclick="func()">
    按钮
</button>
```

* 直接绑定

  只能绑定一个函数

```js
btn.onclick = function(){}
```

* 事件监听

  可绑定多个函数，既可设置捕获事件，也可设置冒泡事件

```js
btn.addEventListener('click', function(){})
```

# 事件委托

事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件

所有用到按钮的事件（多数鼠标事件好键盘事件）都适合采用事件委托技术

使用事件委托可以节省内存

```html
<ul>
    <li>苹果</li>
    <li>香蕉</li>
    <li>橘子</li>
</ul>
```

```js
//good
document.querySelector('ul').onclick = (event) => {
    let target = event.target;
    if(target.nodeName === 'LI'){
        console.log(target.innerHTML);
    }
}
//bad
document.querySelectorAll('li').forEach((e) => {
    e.onclick = function(){
        console.log(this.innerHTML);
    }
})
```

# 原型链





# 闭包

闭包指有权访问另一个函数作用域中的变量的函数



例：有一个函数，参数是一个函数，返回值也是一个函数，返回的函数功能和入参的函数相似，但这个函数只能执行3次，再次执行无效，如何实现？

```js
function sayHi(){
    console.log('Hi');
}

function threeTimes(fn){
    let times = 0;
    return () => {
        if(times++ < 3){
            fn();
        }
    }
}

const newFn = threeTimes(sayHi);
```

# JavaScript 严格模式下有哪些不同？

* 不允许不使用 var 关键字去创建全局变量，抛出 ReferenceError
* 不允许对变量使用 delete 操作符，抛 ReferenceError
* 不可对对象的只读属性赋值，不可对对象的不可配置属性使用 delete 操作符，不可为不可拓展的对象添加属性，均抛 TypeError
* 对象属性名必须唯一
* 函数中不可有重名参数
* 在函数内部对修改参数不会反映到 arguments 中
* 淘汰 arguments.callee 和 arguments.caller
* 不可在 if 内部声明函数
* 抛弃 with 语句

# new操作符

**`new`** 关键字会进行如下的操作：

1. 创建一个空的简单JavaScript对象（即`{}`）；
2. 链接该对象（设置该对象的**constructor**）到另一个对象 ；
3. 将步骤1新创建的对象作为`this`的上下文 ；
4. 如果该函数没有返回对象，则返回`this`。

（译注：关于对象的 **constructor**，参见 **Object.prototype.constructor**）

创建一个用户自定义的对象需要两步：

1. 通过编写函数来定义对象类型。
2. 通过 `new` 来创建对象实例。

创建一个对象类型，需要创建一个指定其名称和属性的函数；对象的属性可以指向其他对象，看下面的例子：

当代码 `new Foo(...)` 执行时，会发生以下事情：

1. 一个继承自 `Foo.prototype` 的新对象被创建。
2. 使用指定的参数调用构造函数 *`Foo`*，并将 `this` 绑定到新创建的对象。`new Foo` 等同于 *`new Foo`*`()`，也就是没有指定参数列表，*`Foo`* 不带任何参数调用的情况。
3. 由构造函数返回的对象就是 `new` 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤）

# Ajax

AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。

AJAX 不是新的编程语言，而是一种使用现有标准的新方法。

AJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。

AJAX 不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行。

## ajax优缺点

优点：

* 交互性更好，来自服务器的新内容可以动态更改，无需重新加载整个页面
* 减少与服务器的连接，因为脚本和样式只需要被请求一次
* 状态可以维护在一个页面上，JavaScript变量和DOM状态将得到保持，因为主容器页面未被重新加载
* 基本上包括大部分SPA的优点

缺点：

* 动态网页很难收藏
* 如果JavaScript已在浏览器中被禁用，则不起作用
* 有些网络爬虫不执行JavaScript，也不会看到JavaScript加载的内容
* 基本上包括大部分SPA的缺点，搜索引擎优化比较难

## Ajax与Fetch区别

* ajax使用XMLHttpRequest对象发起，但是用起来很麻烦，所以ES6新规范有了fetch，fetch是一个请求，不用想ajax一样写一大堆代码
* 使用fetch无法取消一个请求，因为fetch基于Promise，而Promise无法做到这一点
* 在默认情况下，fetch不会接受或者发送cookies
* fetch无法原生检测请求的进度，XMLHttpRequest可以
* fetch支队网络请求报错，对400，500都当做成功的请求，需要封装去处理
* fetch由于是ES6规范，兼容性比不上XMLHttpRequest

# Cookie localStorage sessionStorage

|                | 初始化                                           | 数据生命周期                                                 | 存放数据大小 | 与服务器通信                                                 | 用途                               | 访问权限     |
| -------------- | ------------------------------------------------ | ------------------------------------------------------------ | ------------ | ------------------------------------------------------------ | ---------------------------------- | ------------ |
| cookie         | 客户端或服务器，服务器可以使用`Set-Cookie`请求头 | 一般由服务器生成，可设置失效时间，如果在浏览器生成，默认是关闭浏览器后失效 | 4KB          | 每次都会携带在http头中，如果使用cookie保存过多数据，会带来性能问题 | 一般由服务器生成，用于标识用户身份 | 任意窗口     |
| localStorage   | 客户端                                           | 永久保存，可清除                                             | 5MB          | 仅在客户端保存                                               | 用于浏览器缓存数据                 | 任意窗口     |
| sessionStorage | 客户端                                           | 仅在当前会话有效，关闭页面后清除                             | 5MB          | 仅在客户端保存                                               | 用于浏览器缓存数据                 | 当前页面窗口 |

# 创建对象的方式

```js
//字面量
let a = {username: "admin"}
//工厂模式
function factory(){
    return {
        username: "admin"
    }
}
//构造函数
function Fn(){
    this.username = "admin";
}
let a = new Fn();
//class
class Fn{
    constructor(){
        this.name = "admin";
    }
}
let a = new Fn();
```

# 改变this的指向

## call apply bind 箭头函数 new

call和apply区别在于传参时参数是一个个传还是以数组方式来传

call apply都是在调用时生效，改变调用者的this指向

> `call()` 方法使用一个指定的 `this` 值和单独给出的一个或多个参数来调用一个函数。

```js
function Product(name, price) {
  this.name = name;
  this.price = price;
}

function Food(name, price) {
  Product.call(this, name, price);
  this.category = 'food';
}

console.log(new Food('cheese', 5).name);
// expected output: "cheese"
```

> `apply()` 方法调用一个具有给定`this`值的函数，以及以一个数组（或类数组对象）的形式提供的参数。

```js
const numbers = [5, 6, 2, 3, 7];

const max = Math.max.apply(null, numbers);

console.log(max);
// expected output: 7

const min = Math.min.apply(null, numbers);

console.log(min);
// expected output: 2
```

bind不是在调用时生效，而是返回一个新函数

> `bind()` 方法创建一个新的函数，在 `bind()` 被调用时，这个新函数的 `this` 被指定为 `bind()` 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。

```js
const module = {
  x: 42,
  getX: function() {
    return this.x;
  }
};

const unboundGetX = module.getX;
console.log(unboundGetX()); // The function gets invoked at the global scope
// expected output: undefined

const boundGetX = unboundGetX.bind(module);
console.log(boundGetX());
// expected output: 42
```

箭头函数以外部上下文this为准

new使this指向新创建的对象

## 简述JavaScript中的this

this取值符合以下规则

1. 在调用函数时使用new关键字，函数内的this是一个全新的对象

2. 如果apply，call，bind方法用于调用，创建一个函数，函数内的this就是作为参数传入这些方法时的对象

3. 当函数作为对象里的方法被调用时，函数内的this是调用该函数的对象，比如当`obj.method()`被调用时，函数内的this将绑定到obj对象

4. 如果调用函数不符合上述规则，那么this的值指向全局对象，浏览器环境下this的值指向window对象，但在严格模式下，this的值为undefined

5. 如果符合上述多个规则，则较高的规则(1最高，4最低)将决定this的值
6. 如果该函数是ES2015中的箭头函数，将忽略上述所有规则，this被设置为它被创建时的上下文

#  浏览器的渲染机制

* 浏览器采用流式布局模型(Flow Based Layout)
* 浏览器会把HTML解析成DOM，把CSS解析为CSSOM，DOM和CSSOM合并就产生了渲染树(Render Tree)
* 有了渲染树，我们就知道了所有节点的样式，，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上
* 由于浏览器使用流式布局，对渲染树的计算通常只需要遍历依次就可以完成，但table及其内部元素除外，它们可能需要多次计算，通常要花3倍于同等元素的事件，这也是为什么要避免使用table布局的原因之一

## 重绘

由于节点的几何属性发生改变或由于样式发生改变而不会影响布局的，称为重绘，例如outline，visibility，color，background-color等，重绘的代价是高昂的，因为浏览器必须验证DOM树上其他节点元素的可见性

## 回流(重排)

回流是布局或者几何属性需要改变就称为回流。回流是影响浏览器性能的关键因素，因为其变化涉及到部分页面(或是整个页面)的局部更新，一个元素的回流可能导致其所有子元素以及DOM中紧随其后的节点、祖先结点元素的随后的回流

* **回流比重绘代价更高**
* **回流发生必定发生重绘，重绘不一定发生回流**

## 浏览器优化

现代浏览器大多都是通过队列机制来批量更新布局，浏览器会把修改操作放在队列中，至少一个浏览器刷新(16.6ms)才会清空队列，但当你获取布局信息的时候，队列中可能会有影响这些属性或方法返回值的操作，即使没有，浏览器也会强制清空队列，触发回流与重绘来确保返回正确的值。

会触发回流和重绘的属性和方法有：

* `offsetTop offsetLeft offsetWidth offsetHeight`
* `scrollTop scrollLeft scrollWidth scrollHeight`
* `clientTop clientLeft clientWidth clientHeight`
* `width height`
* `getComputedStyle()`
* `getBoundingClientRect()`

应尽量避免频繁使用上述属性

## 减少重绘与回流

### CSS

* **使用`transform`替代`top`**
* **使用`visibility: hidden`代替`display: none`**，因为前者只会引起重绘，后者会引发回流(改变了布局)
* **避免使用`table`布局**，可能很小的改动会造成整个**`table`**的重新布局
* **尽可能在DOM树的最末端改变class**，回流是不可避免的，但可以减少其影响。尽可能在DOM树的最末端改变class，可以限制回流的范围，使其影响尽可能少的节点
* **避免设置多层内联样式**，CSS选择符从右往左匹配查找，避免节点层级过多
* **将动画效果应用到`position`为`absolute`或`fixed`的元素上**，避免影响其他元素的布局，这样只是一个重绘，而不是回流，同时，控制动画速度可以选择`requestAnimationFrame()`

* **避免使用CSS表达式**，可能会引发回流
* **将频繁重绘或回流的节点设置为图层**，图层能够阻止该节点的渲染行为影响别的节点，例如`will-change video iframe`等标签，浏览器会自动将该节点变成图层
* **CSS3硬件加速(GPU加速)**，使用CSS3硬件加速，可以让`transform opacity filters`这些动画不引起回流和重绘，但是对于动画的其他属性，比如`background-color`这些，还是会引起回流重绘，不过还是可以提升这些动画的性能

### JavaScript

* **避免频繁操作样式**，最好一次性重写`style`属性，或者将样式列表定义为`class`并一次性更改`class`属性
* **避免频繁操作DOM**，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中
* **避免频繁读取会引发回流重绘的属性**，如果需要多次使用，用一个变量缓存起来
* **对具有复杂动画的元素使用绝对定位**，使它脱离文档流，否则会引起父元素及后续元素频繁回流