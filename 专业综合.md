# 进程、线程

* 一个CPU一次只能运行一个任务

* 任一时刻，CPU总是运行一个进程，其它进程处于非运行状态

* 一个进程可以包括多个线程

* 一个进程的内存空间是共享的，每个线程都可以使用这些共享内存
* 不同进程间数据很难共享
* 进程间不会互相影响，一个线程挂掉将导致整个进程挂掉

* 一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存

* **互斥锁**，可以防止多个线程同时读写某一块内存区域

* 某些内存区域，只能供给固定数目的线程使用

* **信号量**，用来保证多个线程不会互相冲突

## 线程

操作系统能够进行运算调度的最小单位，进程中的实际运作单位，一条线程指的是进程中一个单一顺序的控制流

一个线程是一个**执行上下文**，即一个CPU执行时所需要的一串指令

## 进程

一个程序的执行实例就是一个进程，每一个进程提供执行程序所需要的的所有资源

进程本质上是**资源的集合**

一个进程有一个虚拟的地址空间、可执行的代码、操作系统的接口、安全的上下文、唯一的进程ID、环境变量、优先级类、最小和最大工作空间（内存空间），还有至少一个线程

## 区别

1. 同一个进程中的线程共享统一内存空间，但是进程间是独立的
2. 同一个进程中的所有线程的数据是共享的，进程之间的数据是独立的
3. 对主线程的修改可能会影响其他线程的行为，但父进程的修改（除了删除之外）不会影响其他子进程
4. 线程是一个上下文的执行指令，而进程则是与运算相关的一簇资源
5. 同一个进程的线程之间可以直接通信，但是进程之间的交流需要借助中间代理来实现
6. 创建新的线程很容易，但是创建新的进程需要父进程做一次复制
7. 一个线程可以操作同一进程的其他线程，但是进程只能操作其子进程
8. 线程启动速度快，进程启动速度慢（但两者运行速度没有可比性）

# 常见数据结构及用途

## 表

### 三种表

普通表

栈是LIFO（后进先出）表

队列是FIFO（先进先出）表

### 表的两种实现

* **数组**需要连续的内存空间，所以访问时可以直接访问索引，但插入删除时需要移动大量的元素

  数组一般需要确定大小，所以一般从栈中分配空间（广义上的数组，也可以从堆中获取，数组本质上不过是指针的语法糖衣）

* **链表**不需要连续的内存空间，访问时需要从前向后遍历，插入删除时常数时间即可完成

  链表大小动态分配，从堆中分配空间

### 应用

​	栈：平衡符号（括号的成对匹配）；后缀表达式；中缀到后缀的转换；函数调用

​	队列：排队论；任务队列；图论中有大量应用；消息队列；Linux内核进程队列

## 树

### 红黑树的应用

- STL中的map和set的实现
- 著名的linux进程调度[Completely Fair Scheduler]，用红黑树管理进程控制块
- epoll在内核中的实现，用红黑树管理事件块
- nginx中，用红黑树管理timer等
- Java的TreeMap实现

### B/B+树的应用

- B和B+主要用在文件系统以及数据库中做索引等，比如Mysql：[B-Tree Index in MySql](https://link.jianshu.com/?t=https://guptavikas.wordpress.com/2012/12/17/b-tree-index-in-mysql/)

### Trie树（字典树）的应用

- 用在统计和排序大量字符串，如自动机
- trie 树的一个典型应用是前缀匹配，比如下面这个很常见的场景，在我们输入时，搜索引擎会给予提示
- IP选路，也是前缀匹配，一定程度会用到trie