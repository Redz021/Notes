# BFC IFC GFC FFC

CSS2.1中只有BFC，IFC；CSS3中有GFC，FFC

## BFC

块级格式化上下文

页面上一块隔离的渲染区域，容器内的子元素不会在布局上影响到外面的元素，反之亦然

### **触发方式**

* float不为none
* overflow不为visible
* position不为relative或static
* display为table-cell, table-caption, inline-block, flex

### **作用**

常见的多栏布局，结合块级元素浮动，内部元素在一个相对隔离的环境中运行

### 特性

* 同一个BFC下margin会发生折叠

  可将其中一个元素放在独立的BFC中

* BFC可以包含浮动元素

  可以解决高度塌陷问题

* BFC可以阻止元素被浮动元素覆盖

## IFC

内联格式化上下文

IFC的line-box高度由包含的行内元素中最高的实际高度计算而来 不受竖直方向padding和margin的影响

IFC中line-box一般紧贴左右两侧，会受到float元素扰乱，float元素会位于IFC和line-box之间，使得line-box宽度缩短。同一IFC下的多个line-box高度会不同

IFC中不能存在块级元素，插入块级元素会产生两个匿名块与插入的块级元素分开，即产生两个IFC，每个IFC对外表现为块级元素，与插入的块级元素垂直排列

### 作用

* 水平居中：可设置inline-block在外层产生IFC，通过text-align将其水平居中
* 垂直居中：创建一个IFC，用其中一个元素撑起父元素的高度，设置vertical-align: middle，其他行内元素可在此父元素下垂直居中

## GFC

网格布局格式化上下文

当元素设置display: grid时，元素会获得一个独立的渲染区域，可以通过在**网格容器(grid container)**上定义**网格定义行(grid definition rows)**和**网格定义列(grid definition columns)**属性在**网格项目(grid item)**上定义**网格行(grid row)**和**网格列(grid column)**为每一个网格项目定义位置和空间

### 作用

与table相比，grid布局会有更加丰富的属性来控制行列，控制对齐和更为精细的渲染语义和控制

## FFC

自适应格式化上下文

display为flex或inline-flex时会生成自适应容器

容器中每一个子元素都是一个伸缩项目，伸缩项目数量随意

# div水平居中、垂直居中方法

## absolute+transform

```css
#method1 {
            background: #666;
            position: relative;
            width: 500px;
            height: 400px;
        }
        
#method1 div {
            background: #333;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            height: 300px;
        }
```

![image-20201002104950034](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20201002104950034.png)

## absolute+margin

确定当前div宽度，margin值为当前div宽度一半的负值

```css
#method2 div {
            width: 300px;
            height: 300px;
            background: #333;
            position: absolute;
            left: 50%;
            top: 50%;
            margin-left: -150px;
            margin-top: -150px;
        }
```

效果同上

***

left right top bottom均设置为0，margin设置auto

优点：无需了解容器宽高

```css
#method3 div {
            width: 300px;
            height: 300px;
            background: #333;
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            bottom: 0;
            margin: auto;
        }
```

## flex

使用align-items和justify-contents或者直接设置margin: auto

```css
#method4 {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 500px;
            width: 700px;
            background: #6af;
        }
#method4 div {
            width: 300px;
            height: 300px;
            background: #666;
        }
```

## table-cell

display: table-cell配合vertical-align: middle和text-align: center

**内部子元素须设置为inline-block**

```css
#method5 {
            display: table-cell;
            vertical-align: middle;
            text-align: center;
            width: 500px;
            height: 400px;
            background: chocolate;
        }
#method5 div {
            padding: 5px;
            border: 1px solid black;
            display: inline-block;
        }
```

## calc()

```css
#method6 {
            position: relative;
            width: 500px;
            height: 400px;
            background: chocolate;
        }
#method6 div {
            position: absolute;
            width: 300px;
            height: 300px;
            left: calc((500px - 300px)/2);
            top: calc((400px - 300px)/2);
            background: white;
        }
```

# display visibility opacity

|                    | DOM结构                                  | 事件监听            | 性能                                   | 继承                                                    | transition                         |
| ------------------ | ---------------------------------------- | ------------------- | -------------------------------------- | ------------------------------------------------------- | ---------------------------------- |
| display: none      | 浏览器不渲染，不占用空间                 | 无法进行DOM事件监听 | 动态改变此属性会引起重排，性能较差     | 不会被子元素继承，因为子元素也不会被渲染                | transition不支持display            |
| visibility: hidden | 元素被隐藏，但是被渲染不会消失，占用空间 | 无法进行DOM事件监听 | 动态改变此属性会引起重绘，性能较好     | 会被子元素继承，子元素可设置visibility: visible取消隐藏 | visibility会立即显示，隐藏时会延时 |
| opacity: 0         | 透明度0%，元素隐藏，占用空间             | 可以进行DOM事件监听 | \*提升为合成层，不触发重绘，性能较好\* | 会被子元素继承，子元素无法使用opacity: 1取消隐藏        | opacity可以延时显示和隐藏          |

\*在 Blink 和 WebKit 内核的浏览器中，对于应用了 transition 或者 animation的 opacity 元素，浏览器会将渲染层提升为合成层。

# 覆盖元素宽度

例：在不改变当前代码情况下，使这张图片宽度变为300px

```html
<img src="1.jpg" style="width: 480px!important;"/>
```

解答：

1. **CSS方法**

   ```html
   <img src="1.jpg" style="width: 480px!important;max-width: 300px;"/>
   <img src="1.jpg" style="width: 480px!important;transform: scale(0.625, 1);"/>
   <img src="1.jpg" style="width: 480px!important;width: 300px!important;"/>
   ```

2. **JS方法**

   ```javascript
   document.getElementByTagName("img")[0].setAttribute("style","width:300px!important;");
   ```

# Retina屏幕1px边框问题

CSS中的1px并不等于移动设备的1px，不同设备有不同的像素密度

`window`对象中有一个`devicePixelRatio`属性，表示CSS中的像素和设备的像素比

> MDN定义：`window`接口的`devicePixelRatio`返回当前显示设备的*物理像素*分辨率与*CSS像素分辨率*之比。

简单来说，他告诉浏览器应使用多少屏幕实际像素来绘制单个CSS像素。

**解决办法：**

## 0.5px边框

可以通过JavaScript检测浏览器能否处理0.5px的边框，如果可以则给HTML标签元素添加class

```javascript
if(window.devicePixelRatio && devicePixelRatio >= 2){
	var testElem = document.createElement('div');
	testElem.style.border = '.5px solid transparent';
	document.body.appendChild(testElem);
	if(testElem.offsetHeight == 1){
		document.querySelector('html').classList.add('hairlines');
	}
	document.body.removeChild(testElem);
}
```

```css
div{
	border: 1px solid black;
}
.hairlines div{
	border-width: 0.5px;
}
```

## border-image

使用高2px的边框图片，一半透明一半有色，压缩为高1px的边框

修改颜色麻烦，需要更换图片

圆角需要特殊处理，并且边缘会模糊

## background-image

准备一张符合要求的图片

```css
.background-image-1px{
	background: url(../image/line.jpg) repeat-x left bottom;
	background-size: 100% 1px;
}
```

缺点同上

## 多背景渐变实现

与background-image类似，只是将图片替换为CSS3渐变，设置1px的渐变背景，50%有颜色，50%透明

```css
.background-gradient-1px{
	background: linear-gradient(180deg, black, black 50%, transparent 50%) top left / 100% 1px no-repeat,
				linear-gradient(90deg, black, black 50%, transparent 50%) top right / 1px 100% no-repeat,
				linear-gradient(0deg, black, black 50%, transparent 50%) bottom right / 100% 1px no-repeat,
				linear-gradient(-90deg, black, black 50%, transparent 50%) bottom left / 1px 100% no-repeat;
}
/*或者*/
.background-gradient-1px{
	background: -webkit-gradient(linear, left top, left bottom, color-stop(.5, transparent), color-stop(.5, #c8c7cc), 							to(#c8c7cc)) left bottom repeat-x;
	background-size: 100% 1px;
}
```

## box-shadow

inset内阴影

```css
.box-shadow-1px{
	box-shadow: inset 0px -1px 1px -1px #c8c7cc;
}
```

## viewport+rem(最常用)

同时通过设置对应viewport的rem基准值

这种兼容方案相对比较完美，适合新项目，老项目修改成本过高

## 伪类+transform

原理：把原来元素的border去掉，然后利用`:before`或者`:after`重做border，并transform的scale缩小一半，原先的元素相对定位，新做的border绝对定位

**单条边框**

```css
.scale-1px{
	position: relative;
	border: none;
}
.scale-1px:after{
	content: '';
	position: absolute;
	bottom: 0;
	background: #000;
	width: 100%;
	height: 1px;
	transform: scaleY(0.5);
	transform-origin: 0 0;
}
```

# 六种常见的前端构建工具

npm script , grunt, gulp, fis3, webpack, rollup

# 浏览器兼容问题

## 原因

* 同一产品，版本越老bug越多
* 同一产品，版本越新功能越多
* 不同产品，不同标准，不同实现方式

## 处理思路

1. **要不要做**

* 产品的角度（产品的受众，受众的浏览器比例，效果优先还是基本功能优先）
* 成本的角度（有没有必要）

2. **做到什么程度**

* 让哪些浏览器支持哪些效果

3. **如何做**

* 根据兼容需求选择技术框架/库
* 根据兼容需求选择兼容工具（html5shiv.js, respond.js, css reset, normalize.css Modernizr）
* 条件注释，CSS Hack，js能力检测做一些修补
* 渐进增强（progressive enhancement）：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果，交互的等改进和追加功能达到更好的用户体验
* 优雅降级（graceful degraduation）：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容

# 性能优化

* 减少HTTP请求
* 减少DOM操作
* 避免不必要的重绘与重排
* 优化CSS选择器（从右向左匹配）
* CSS/JS minify，减少文件体积
* 开启gzip压缩
* 将css放到顶部，JavaScript放到尾部
* 压缩图片以及使用CSS sprite
* 使用CDN加速，适当进行文件缓存
* 合理控制cookie大小（每次请求都会包含cookie）

# 安全性问题

## XSS(Cross Site Scripting)

### 定义

**跨站脚本攻击**是指恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。
 xss漏洞通常是通过php的输出函数将javascript代码输出到html页面中，通过用户本地浏览器执行的，所以xss漏洞关键就是**寻找参数未过滤的输出函数**。
 常见的输出函数有： `echo printf print print_r sprintf die var-dump var_export`.

### 危害

- 挂马
- 盗取用户Cookie。
- DOS（拒绝服务）客户端浏览器。
- 钓鱼攻击，高级的钓鱼技巧。
- 删除目标文章、恶意篡改数据、嫁祸。
- 劫持用户Web行为，甚至进一步渗透内网。
- 爆发Web2.0蠕虫。
- 蠕虫式的DDoS攻击。
- 蠕虫式挂马攻击、刷广告、刷浏量、破坏网上数据
- 其他安全问题

[更多](https://blog.csdn.net/qw_xingzhe/article/details/80712840)

### 攻击方式

常用的XSS攻击手段和目的有：

1、盗用cookie，获取敏感信息。

2、利用植入Flash，通过crossdomain权限设置进一步获取更高权限；或者利用Java等得到类似的操作。

3、利用iframe、frame、XMLHttpRequest或上述Flash等方式，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作。

4、利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动。

5、在访问量极大的一些页面上的XSS可以攻击一些小型网站，实现DDoS攻击的效果。

### 防御

**(1)基于特征的防御**。XSS漏洞和著名的SQL注入漏洞一样，都是利用了Web页面的编写不完善，所以每一个漏洞所利用和针对的弱点。都不尽相同。这就给XSS漏洞防御带来了困难，不可能以单一特征来概括所有XSS攻击。

传统的XSS防御在进行攻击鉴别时多采用特征匹配方式，主要是针对“javascript”这个关键字进行检索，但是这种鉴别不够灵活，凡是提交的信息中各有“javascript”时，就被硬性的被判定为XSS攻击。

**(2)基于代码修改的防御**。Web页面开发者在编写程序时往往会出现一些失误和漏洞，XSS攻击正是利用了失误和漏洞，因此一种比较理想的方法就是通过优化Web应用开发来减少漏洞，避免被攻击：1)用户向服务器上提交的信息要对URL和附带的的HTTP头、POST数据等进行查询，对不是规定格式、长度的内容进行过滤。2)实现Session标记（session tokens）、CAPTCHA系统或者HTTP引用头检查，以防功能被第三方网站所执行。3)确认接收的的内容被妥善的规范化，仅包含最小的、安全的Tag（没有javascript），去掉任何对远程内容的引用（尤其是样式表和javascript），使用HTTP only的cookie。

当然，如上操作将会降低Web业务系统的可用性，用户仅能输入少量的制定字符，人与系统间的交互被降到极致，仅适用于信息发布型站点。并且考虑到很少有Web编码人员受过正规的安全培训，很难做到完全避免页面中的XSS漏洞。

**(3)客户端分层防御策略**。客户端跨站脚本攻击的分层防御策略是基于独立分配线程和分层防御策略的安全模型。它建立在客户端(浏览器)，这是它与其他模型最大的区别，之所以客户端安全性如此重要，客户端在接受服务器信息，选择性的执行相关内容。这样就可以使防御XSS攻击变得容易，该模型主要由三大部分组成：1)对每一个网页分配独立线程且分析资源消耗的“网页线程分析模块”；2)包含分层防御策略四个规则的用户输入分析模块；3)保存互联网上有关XSS恶意网站信息的XSS信息数据库。 [3] 

XSS攻击主要是由程序漏洞造成的，要完全防止XSS安全漏洞主要依靠程序员较高的编程能力和安全意识，当然安全的软件开发流程及其他一些编程安全原则也可以大大减少XSS安全漏洞的发生。这些防范XSS漏洞原则包括：

（1）不信任用户提交的任何内容，对所有用户提交内容进行可靠的输入验证，包括对URL、查询关键字、HTTP头、REFER、POST数据等，仅接受指定长度范围内、采用适当格式、采用所预期的字符的内容提交，对其他的一律过滤。尽量采用POST而非GET提交表单；对“<”，“>”，“；”，“””等字符做过滤；任何内容输出到页面之前都必须加以en-code，避免不小心把htmltag显示出来。

（2）实现Session 标记（session tokens）、CAPTCHA（验证码）系统或者HTTP引用头检查，以防功能被第三方网站所执行，对于用户提交信息的中的img等link，检查是否有重定向回本站、不是真的图片等可疑操作。

（3）cookie 防盗。避免直接在cookie中泄露用户隐私，例如email、密码，等等；通过使cookie和系统IP绑定来降低cookie泄露后的危险。这样攻击者得到的cookie没有实际价值，很难拿来直接进行重放攻击。

（4）确认接收的内容被妥善地规范化，仅包含最小的、安全的Tag（没有JavaScript），去掉任何对远程内容的引用（尤其是样式表和JavaScript），使用HTTPonly的cookie。

## CSRF/XSRF(Cross—Site Request Forgery)

### 概念

**CSRF跨站点请求伪造(Cross—Site Request Forgery)**，跟XSS攻击一样，存在巨大的危害性，你可以这样来理解：
    攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 如下：其中Web A为存在CSRF漏洞的网站，Web B为攻击者构建的恶意网站，User C为Web A网站的合法用户。

### 原理

1. 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；
2. 在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；
3. 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；
4. 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；
5. 浏览器在接收到这些攻击性代码后，根据网站 B 的请求，在用户不知情的情况下携带 Cookie 信息，向网站 A 发出请求。网站 A 并不知道该请求其实是由 B 发起的，所以会根据用户 C 的 Cookie 信息以 C 的权限处理该请求，导致来自网站 B 的恶意代码被执行。 

### 实例

​		受害者 Bob 在银行有一笔存款，通过对银行的网站发送请求 http://bank.example/withdraw?account=bob&amount=1000000&for=bob2 可以使 Bob 把 1000000 的存款转到 bob2 的账号下。通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该 session 的用户 Bob 已经成功登陆。

​		黑客 Mallory 自己在该银行也有账户，他知道上文中的 URL 可以把钱进行转帐操作。Mallory 可以自己发送一个请求给银行：http://bank.example/withdraw?account=bob&amount=1000000&for=Mallory。但是这个请求来自 Mallory 而非 Bob，他不能通过安全认证，因此该请求不会起作用。

​		这时，Mallory 想到使用 CSRF 的攻击方式，他先自己做一个网站，在网站中放入如下代码： src=”http://bank.example/withdraw?account=bob&amount=1000000&for=Mallory ”，并且通过广告等诱使 Bob 来访问他的网站。当 Bob 访问该网站时，上述 url 就会从 Bob 的浏览器发向银行，而这个请求会附带 Bob 浏览器中的 cookie 一起发向银行服务器。大多数情况下，该请求会失败，因为他要求 Bob 的认证信息。但是，如果 Bob 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，浏览器的 cookie 之中含有 Bob 的认证信息。这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 Bob 的账号转移到 Mallory 的账号，而 Bob 当时毫不知情。等以后 Bob 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 Mallory 则可以拿到钱后逍遥法外。 

### 检测

​		检测CSRF漏洞是一项比较繁琐的工作，最简单的方法就是抓取一个正常请求的数据包，去掉Referer字段后再重新提交，如果该提交还有效，那么基本上可以确定存在CSRF漏洞。

​    	随着对CSRF漏洞研究的不断深入，不断涌现出一些专门针对CSRF漏洞进行检测的工具，如CSRFTester，CSRF Request Builder等。

​    	以CSRFTester工具为例，CSRF漏洞检测工具的测试原理如下：使用CSRFTester进行测试时，首先需要抓取我们在浏览器中访问过的所有链接以及所有的表单等信息，然后通过在CSRFTester中修改相应的表单等信息，重新提交，这相当于一次伪造客户端请求。如果修改后的测试请求成功被网站服务器接受，则说明存在CSRF漏洞，当然此款工具也可以被用来进行CSRF攻击。

### 防御

目前防御 CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token 并验证；在 HTTP 头中自定义属性并验证。

* **验证 HTTP Referer 字段**

​		根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问 http://bank.example/withdraw?account=bob&amount=1000000&for=Mallory，用户必须先登陆 bank.example，然后通过点击页面上的按钮来触发转账事件。这时，该转帐请求的 Referer 值就会是转账按钮所在的页面的 URL，通常是以 bank.example 域名开头的地址。而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。

​    	这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。

​    	然而，这种方法并非万无一失。Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全。事实上，对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值。如果 bank.example 网站支持 IE6 浏览器，黑客完全可以把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行 CSRF 攻击。

​		即便是使用最新的浏览器，黑客无法篡改 Referer 值，这种方法仍然有问题。因为 Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心 Referer 值会把组织内网中的某些信息泄露到外网中。因此，用户自己可以设置浏览器使其在发送请求时不再提供 Referer。当他们正常访问银行网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。

* **在请求地址中添加 token 并验证**

​		CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。

​    	这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 http://url?csrftoken=tokenvalue。 而对于 POST 请求来说，要在 form 的最后加上 \<input type="hidden" name="csrftoken" value="tokenvalue"/>，这样就把 token 以参数的形式加入请求了。但是，在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token。

​		该方法还有一个缺点是难以保证 token 本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上 token，黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。

* **在 HTTP 头中自定义属性并验证**

​		这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。

​		然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。

# 圣杯布局 双飞翼布局

## 什么是圣杯布局？

圣杯布局是为了讨论*三栏液态布局*的实现，最早的完美实现是由Matthew Levine在2006年写的一篇文章《In Search of the Holy Grail》，它主要讲述了网页中关于最佳圣杯的实现方法。

圣杯布局和双飞翼布局达到的效果基本相同，都是侧边两栏宽度固定，中间栏宽度自适应。 主要的不同之处就是在解决中间部分被挡住的问题时，采取的解决办法不一样。

* 圣杯布局是在父元素上设置了padding-left和padding-right，在给左右两边的内容设置position为relative，通过左移和右移来使得左右两边的内容得以很好的展现，

* 而双飞翼则是在center这个div中再加了一个div来放置内容，在给这个新的div设置margin-left和margin-right 。

圣杯布局有以下几点要求：

* 上部(header)和下部(footer)各自占领屏幕所有宽度
* 上下部之前的部分(container)是一个三栏布局
* 三栏布局两侧宽度不变，中间部分自动填充整个区域
* 中间部分的高度是三栏中最高的区域的高度

有两种实现的方法：浮动和flex

## 方法1：浮动

```html
<div class="header">
    <h4>header</h4>
</div>

<div class="container">
    <div class="middle">
        <h4>middle</h4>
        <p>middle-content</p>
    </div>
    <div class="left">
        <h4>left</h4>
        <p>left-content</p>
    </div>
    <div class="right">
        <h4>right</h4>
        <p>right-content</p>
    </div>
</div>

<div class="footer">
    <h4>footer</h4>
</div>
```

```css
.header, .footer{
    border: 1px solid #333;
    background: #ccc;
    text-align: center;
}
.footer{
    clear: both;
}
.container{
    padding: 0 220px 0 200px;
    overflow: hidden;
}
.left, .middle, .right{
    position: relative;
    float: left;
    min-height: 130px;
}
.middle{
    width: 100%;
    background: blue;
}
.left{
    margin-left: -100%;
    left: -200px;
    width: 200px;
    background: red;
}
.right{
    margin-left: -220px;
    right: -220px;
    width: 220px;
    background: green;
}
```

思路：

* 使header和footer横向撑满
* container中的三列设为浮动和相对定位(后面会用到)，middle放在最前面，footer清除浮动
* 三列的左右两列分别定宽200px和220px，中间部分middle设置100%撑满
* 因为浮动，middle会占据整个container，左右被挤下去
* 设置left的`margin-left: -100%;`让left回到上一行最左侧，但会把middle遮住，所以给外层的container设置`padding: 0 220px 0 200px;`给left空出位置

* 这时left并没有在最左侧，因为之前已经设置过相对定位，所以通过`left: -200px;`把left拉回最左侧
* 同样对于right区域，设置`margin-left: -220px;`把right拉回第一行，这时右侧空出了220px空间，所以最后设置`right: -220px;`把right拉到最右侧

## 方法2：flex弹性盒子

```css
.header, .footer{
    border: 1px solid #333;
    background: #ccc;
    text-align: center;
}
.container{
    display: flex;
}
.left{
    width: 200px;
    background: red;
}
.middle{
    flex: 1;
    background: blue;
}
.right{
    width: 220px;
    background: green;
}
```

思路：

* header和footer同上，footer不再需要清除浮动
* container中的left，middle，right依次排布即可，不用特意把middle放置到最前面
* 给container设置弹性布局`display: flex;`
* left和right定宽，middle设置`flex: 1;`

## 双飞翼布局

```html
<div class="header">
    <h4>header</h4>
</div>

<div class="container">
    <div class="middle">
        <div class="inner-middle">
            <h4>middle</h4>
        	<p>middle-content</p>
        </div>
    </div>
    <div class="left">
        <h4>left</h4>
        <p>left-content</p>
    </div>
    <div class="right">
        <h4>right</h4>
        <p>right-content</p>
    </div>
</div>

<div class="footer">
    <h4>footer</h4>
</div>
```



```css
.header, .footer{
    border: 1px solid #333;
    background: #ccc;
    text-align: center;
}
.footer{
    clear: both;
}
.container{
    overflow: hidden;
}
.left, .middle, .right{
    float: left;
    min-height: 130px;
}
.left{
    margin-left: -100%;
    width: 200px;
    background: red;
}
.right{
    margin-left: -220px;
    width: 220px;
    background: green;
}
.middle{
    width: 100%;
}
.inner-middle{
    margin-left: 200px;
    margin-right: 220px;
    min-height: 130px;
    background: blue;
}
```



# 跨源资源共享（CORS）

**跨源资源共享** ([CORS](https://developer.mozilla.org/zh-CN/docs/Glossary/CORS)) （或通俗地译为跨域资源共享）是一种机制，该机制使用附加的 [HTTP](https://developer.mozilla.org/zh-CN/docs/Glossary/HTTP) 头来告诉浏览器，准许运行在一个源上的Web应用访问位于另一不同源选定的资源。 当一个Web应用发起一个与自身所在源（域，协议和端口）不同的HTTP请求时，它发起的即跨源HTTP请求。

跨源HTTP请求的一个例子：运行在 http://domain-a.com 的JavaScript代码使用[`XMLHttpRequest`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest)来发起一个到 https://domain-b.com/data.json 的请求。

出于安全性，浏览器限制脚本内发起的跨源HTTP请求。 例如，XMLHttpRequest和Fetch API遵循同源策略。 这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，除非响应报文包含了正确CORS响应头。

<img src="https://mdn.mozillademos.org/files/14295/CORS_principle.png" alt="img" style="zoom:80%;" />

跨源域资源共享（ [CORS](https://developer.mozilla.org/zh-CN/docs/Glossary/CORS) ）机制允许 Web 应用服务器进行跨源访问控制，从而使跨源数据传输得以安全进行。现代浏览器支持在 API 容器中（例如 [`XMLHttpRequest`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest) 或 [Fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) ）使用 CORS，以降低跨源 HTTP 请求所带来的风险。

## 什么情况下需要 CORS ？

这份 [cross-origin sharing standard](http://www.w3.org/TR/cors/) 允许在下列场景中使用跨站点 HTTP 请求：

- 前文提到的由 [`XMLHttpRequest`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest) 或 [Fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) 发起的跨源 HTTP 请求。
- Web 字体 (CSS 中通过` @font-face `使用跨源字体资源)，[因此，网站就可以发布 TrueType 字体资源，并只允许已授权网站进行跨站调用](https://www.w3.org/TR/css-fonts-3/#font-fetching-requirements)。
- [WebGL 贴图](https://developer.mozilla.org/zh-CN/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL)
- 使用 `drawImage` 将 Images/video 画面绘制到 canvas

本文概述了跨源资源共享机制及其所涉及的 HTTP 头。

# 跨域问题

同源策略

同源策略可以防止JavaScript发起跨域请求。源被定义为URI、主机名和端口号的组合。此策略可防止页面上的恶意脚本通过该页面的DOM访问另一个网页上的敏感数据

### 原因

浏览器同源策略导致了跨域

### 作用

用于隔离潜在恶意文件的重要安全机制

### 解决

* jsonp，允许script加载第三方资源
* 代理
* cors前后端协作设置响应头部，Access-Control-Allow-Origin："*"等头部信息
* iframe嵌套通讯，postmessage

# Cookie localStorage sessionStorage

|                | 初始化                                           | 数据生命周期                                                 | 存放数据大小 | 与服务器通信                                                 | 用途                               | 访问权限     |
| -------------- | ------------------------------------------------ | ------------------------------------------------------------ | ------------ | ------------------------------------------------------------ | ---------------------------------- | ------------ |
| cookie         | 客户端或服务器，服务器可以使用`Set-Cookie`请求头 | 一般由服务器生成，可设置失效时间，如果在浏览器生成，默认是关闭浏览器后失效 | 4KB          | 每次都会携带在http头中，如果使用cookie保存过多数据，会带来性能问题 | 一般由服务器生成，用于标识用户身份 | 任意窗口     |
| localStorage   | 客户端                                           | 永久保存，可清除                                             | 5MB          | 仅在客户端保存                                               | 用于浏览器缓存数据                 | 任意窗口     |
| sessionStorage | 客户端                                           | 仅在当前会话有效，关闭页面后清除                             | 5MB          | 仅在客户端保存                                               | 用于浏览器缓存数据                 | 当前页面窗口 |

# cookie和session区别

　　1、cookie数据存放在客户的浏览器上，session数据放在服务器上。

　　2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。

　　3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。

　　4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。



1、存取方式的不同

　　Cookie中只能保管ASCII[字符](http://www.hqpcb.com/zhuoluye9)串，假如需求存取Unicode字符或者二进制数据，需求先进行编码。Cookie中也不能直接存取[Java](http://www.elecfans.com/tags/java/)对象。若要存储略微复杂的信息，运用Cookie是比拟艰难的。

　　而Session中能够存取任何类型的数据，包括而不限于String、Integer、List、Map等。Session中也能够直接保管JavaBean乃至任何Java类，对象等，运用起来十分便当。能够把Session看做是一个Java容器类。

2、隐私策略的不同

　　Cookie存储在客户端阅读器中，对客户端是可见的，客户端的一些程序可能会窥探、复制以至修正Cookie中的内容。而Session存储在服务器上，对客户端是透明的，不存在敏感信息泄露的风险。

　　假如选用Cookie，比较好的方法是，敏感的信息如账号密码等尽量不要写到Cookie中。最好是像Google、B[ai](http://www.elecfans.com/tags/ai/)du那样将Cookie信息加密，提交到服务器后再进行解密，保证Cookie中的信息只要本人能读得懂。而假如选择Session就省事多了，反正是放在服务器上，Session里任何隐私都能够有效的保护。

3、有效期上的不同

　　使用过Google的人都晓得，假如登录过Google，则Google的登录信息长期有效。用户不用每次访问都重新登录，Google会持久地记载该用户的登录信息。要到达这种效果，运用Cookie会是比较好的选择。只需要设置Cookie的过期时间属性为一个很大很大的数字。

　　由于Session依赖于名为JSESSIONID的Cookie，而CookieJSESSIONID的过期时间默许为–1，只需关闭了阅读器该Session就会失效，因而Session不能完成信息永世有效的效果。运用URL地址重写也不能完成。而且假如设置Session的超时时间过长，服务器累计的Session就会越多，越容易招致内存溢出。

4、服务器压力的不同

　　Session是保管在服务器端的，每个用户都会产生一个Session。假如并发访问的用户十分多，会产生十分多的Session，耗费大量的内存。因而像Google、Baidu、Sina这样并发访问量极高的网站，是不太可能运用Session来追踪客户会话的。

　　而Cookie保管在客户端，不占用服务器资源。假如并发阅读的用户十分多，Cookie是很好的选择。关于Google、Baidu、Sina来说，Cookie或许是唯一的选择。

5、浏览器支持的不同

　　Cookie是需要客户端浏览器支持的。假如客户端禁用了Cookie，或者不支持Cookie，则会话跟踪会失效。关于WAP上的应用，常规的Cookie就派不上用场了。

　　假如客户端浏览器不支持Cookie，需要运用Session以及URL地址重写。需要注意的是一切的用到Session程序的URL都要进行URL地址重写，否则Session会话跟踪还会失效。关于WAP应用来说，Session+URL地址重写或许是它唯一的选择。

　　假如客户端支持Cookie，则Cookie既能够设为本浏览器窗口以及子窗口内有效（把过期时间设为–1），也能够设为一切阅读器窗口内有效（把过期时间设为某个大于0的整数）。但Session只能在本阅读器窗口以及其子窗口内有效。假如两个浏览器窗口互不相干，它们将运用两个不同的Session。（IE8下不同窗口Session相干）

6、跨域支持上的不同

　　Cookie支持跨域名访问，例如将domain属性设置为“.biaodianfu.com”，则以“.biaodianfu.com”为后缀的一切域名均能够访问该Cookie。跨域名Cookie如今被普遍用在网络中，例如Google、Baidu、Sina等。而Session则不会支持跨域名访问。Session仅在他所在的域名内有效。

　　仅运用Cookie或者仅运用Session可能完成不了理想的效果。这时应该尝试一下同时运用Cookie与Session。Cookie与Session的搭配运用在实践项目中会完成很多意想不到的效果。

#  浏览器的渲染机制

## 浏览器渲染过程

- 解析 HTML 构建 DOM(DOM 树)，并行请求 css/image/js
- CSS 文件下载完成，开始构建 CSSOM(CSS 树)
- CSSOM 构建结束后，和 DOM 一起生成 Render Tree(渲染树)
- 布局(Layout)：计算出每个节点在屏幕中的位置
- 显示(Painting)：通过显卡把页面画到屏幕上

## DOM树和渲染树的区别

- DOM 树与 HTML 标签一一对应，包括 head 和隐藏元素
- 渲染树不包括 head 和隐藏元素，大段文本的每一个行都是独立节点，每一个节点都有对应的 css 属性

## 渲染机制

* 浏览器采用流式布局模型(Flow Based Layout)
* 浏览器会把HTML解析成DOM，把CSS解析为CSSOM，DOM和CSSOM合并就产生了渲染树(Render Tree)
* 有了渲染树，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上
* 由于浏览器使用流式布局，对渲染树的计算通常只需要遍历依次就可以完成，但table及其内部元素除外，它们可能需要多次计算，通常要花3倍于同等元素的事件，这也是为什么要避免使用table布局的原因之一

### CSS会阻塞DOM解析吗？

对于一个HTML文档来说，不管是内联还是外链的css，都会阻碍后续的dom渲染，但是不会阻碍后续dom的解析。

当css文件放在中时，虽然css解析也会阻塞后续dom的渲染，但是在解析css的同时也在解析dom，所以等到css解析完毕就会逐步的渲染页面了。

### 资源外链的下载

#### 遇到外链时的处理

- 遇到外链时，会单独开启一个下载线程去下载资源（http1.1中是每一个资源的下载都要开启一个http请求，对应一个tcp/ip链接）

#### 遇到CSS样式资源

CSS资源的处理有几个特点：

- CSS下载时异步，不会阻塞浏览器构建DOM树
- 会阻塞渲染，也就是**在构建render时，会等到css下载解析完毕后才进行**（这点与浏览器优化有关，防止css规则不断改变，避免了重复的构建）
- media query声明的CSS是不会阻塞渲染的

#### 遇到JS脚本资源

JS脚本资源的处理有几个特点：

- **阻塞浏览器的解析**，也就是说发现一个外链脚本时，需等待脚本下载完成并执行后才会继续解析HTML
- **浏览器的优化**，一般现代浏览器有优化，在脚本阻塞时，也会继续下载其它资源（当然有并发上限），但是**虽然脚本可以并行下载，解析过程仍然是阻塞的，也就是说必须这个脚本执行完毕后才会接下来的解析**，并行下载只是一种优化而已
- defer与async，普通的脚本是会阻塞浏览器解析的，但是可以加上defer或async属性，这样脚本就变成异步了，可以等到解析完毕后再执行 详见异步加载JS

#### 遇到img图片类资源

- 遇到图片等资源时，直接就是异步下载，不会阻塞解析，下载完毕后直接用图片替换原有src的地方

#### loaded和domcontentloaded

简单的对比：

- DOMContentLoaded： 事件触发时，仅当DOM加载完成，不包括样式表，图片(譬如如果有async加载的脚本就不一定完成)
- load： 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了

#### 怎么提高CSS加载速度？

- 使用CDN
- 将CSS压缩
- 合理使用缓存
- 减少HTTP请求数，多个CSS合并

## 重绘

由于节点的几何属性发生改变或由于样式发生改变而不会影响布局的，称为重绘，例如outline，visibility，color，background-color等，重绘的代价是高昂的，因为浏览器必须验证DOM树上其他节点元素的可见性

## 回流(重排)

回流是布局或者几何属性需要改变就称为回流。回流是影响浏览器性能的关键因素，因为其变化涉及到部分页面(或是整个页面)的局部更新，一个元素的回流可能导致其所有子元素以及DOM中紧随其后的节点、祖先结点元素的随后的回流

* **回流比重绘代价更高**
* **回流发生必定发生重绘，重绘不一定发生回流**

## 浏览器优化

现代浏览器大多都是通过队列机制来批量更新布局，浏览器会把修改操作放在队列中，至少一个浏览器刷新(16.6ms)才会清空队列，但当你获取布局信息的时候，队列中可能会有影响这些属性或方法返回值的操作，即使没有，浏览器也会强制清空队列，触发回流与重绘来确保返回正确的值。

会触发回流和重绘的属性和方法有：

* `offsetTop offsetLeft offsetWidth offsetHeight`
* `scrollTop scrollLeft scrollWidth scrollHeight`
* `clientTop clientLeft clientWidth clientHeight`
* `width height`
* `getComputedStyle()`
* `getBoundingClientRect()`

应尽量避免频繁使用上述属性

## 减少重绘与回流

### CSS

* **使用`transform`替代`top`**
* **使用`visibility: hidden`代替`display: none`**，因为前者只会引起重绘，后者会引发回流(改变了布局)
* **避免使用`table`布局**，可能很小的改动会造成整个**`table`**的重新布局
* **尽可能在DOM树的最末端改变class**，回流是不可避免的，但可以减少其影响。尽可能在DOM树的最末端改变class，可以限制回流的范围，使其影响尽可能少的节点
* **避免设置多层内联样式**，CSS选择符从右往左匹配查找，避免节点层级过多
* **将动画效果应用到`position`为`absolute`或`fixed`的元素上**，避免影响其他元素的布局，这样只是一个重绘，而不是回流，同时，控制动画速度可以选择`requestAnimationFrame()`

* **避免使用CSS表达式**，可能会引发回流
* **将频繁重绘或回流的节点设置为图层**，图层能够阻止该节点的渲染行为影响别的节点，例如`will-change video iframe`等标签，浏览器会自动将该节点变成图层
* **CSS3硬件加速(GPU加速)**，使用CSS3硬件加速，可以让`transform opacity filters`这些动画不引起回流和重绘，但是对于动画的其他属性，比如`background-color`这些，还是会引起回流重绘，不过还是可以提升这些动画的性能

### JavaScript

* **避免频繁操作样式**，最好一次性重写`style`属性，或者将样式列表定义为`class`并一次性更改`class`属性
* **避免频繁操作DOM**，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中
* **避免频繁读取会引发回流重绘的属性**，如果需要多次使用，用一个变量缓存起来
* **对具有复杂动画的元素使用绝对定位**，使它脱离文档流，否则会引起父元素及后续元素频繁回流

# 从输入url到页面加载发生了什么

## 总览

- 浏览器地址栏输入URL并回车
- 浏览器查找当前URL是否存在缓存，并比较缓存是否过期
- DNS解析URL对应的IP
- 根据IP建立TCP连接（三次握手）
- 发送HTTP请求
- 服务器处理请求，浏览器接受HTTP响应
- 浏览器解析并渲染页面
- 关闭TCP连接（四次挥手）

## 解析URL

URL的几大部分：

- protocol 协议头：HTTP,HTTPS,FTP
- host 主机域名或IP地址
- port 端口号，http默认80，https默认443
- path 目录路径
- query 查询参数
- fragment #后的哈希值，一般用来定位到某个位置

### HTTP与HTTPS

#### HTTP的缺点：

- 通信使用明文，内容可能被窃听
- 不验证通信方身份，可能遭遇伪装
- 无法验证报文的完整性，有可能被篡改

#### HTTP+加密+认证+完整性保护=HTTPS

- HTTPS是身披SSL外壳的HTTP：通常情况下HTTP是直接和TCP层进行通信的。当使用SSL(安全套接字)时,则演变成**HTTP先和SSL通信,SSL再和TCP通信**。

#### SSL

- 对称加密：加密和解密用同一个密钥，易被截取密钥
- 非对称加密（公开密钥加密）：发送密文一方使用对方的共有密钥进行加密处理,对方收到加密信息后,再使用自己的私有密钥进行解密。
- HTTPS采用二者结合的方式，因为非对称加密相比对称加密处理速度较慢**，所以使用非对称加密传输对称加密的共享密钥，再使用共享密钥进行通信。** **公开密钥的认证是要钱的**！私有密钥保存在服务器端。

#### SSL/TLS握手流程

1. 浏览器请求建立SSL链接，并向服务端发送一个随机数–Client random和客户端支持的加密方法，比如RSA加密，此时是明文传输。 

2. 服务端从中选出一组加密算法与Hash算法，回复一个随机数–Server random，并将自己的身份信息以证书的形式发回给浏览器
（证书里包含了网站地址，非对称加密的公钥，以及证书颁发机构等信息）

3. 浏览器收到服务端的证书后
   
    - 验证证书的合法性（颁发机构是否合法，证书中包含的网址是否和正在访问的一样），如果证书信任，则浏览器会显示一个小锁头，否则会有提示
    
    - 用户接收证书后（不管信不信任），浏览会生产新的随机数–Premaster secret，然后证书中的公钥以及指定的加密方法加密`Premaster secret`，发送给服务器。
    
    - 利用Client random、Server random和Premaster secret通过一定的算法生成HTTP链接数据传输的对称加密key-`session key`
    
    - 使用约定好的HASH算法计算握手消息，并使用生成的`session key`对消息进行加密，最后将之前生成的所有信息发送给服务端。 
    
4. 服务端收到浏览器的回复

    - 利用已知的加解密方式与自己的私钥进行解密，获取`Premaster secret`
    
    - 和浏览器相同规则生成`session key`
    
    - 使用`session key`解密浏览器发来的握手消息，并验证Hash是否与浏览器发来的一致
    
    - 使用`session key`加密一段握手消息，发送给浏览器
    
5. 浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束

**之后所有的https通信数据将由之前浏览器生成的session key并利用对称加密算法进行加密**

#### HTTPS的好处

- SEO：搜索引擎排名更高
- 安全性：
  - 使用https协议**可认证**用户和服务器，确保数据发送到正确的客户机和服务器;
  - https协议是由SSL+http协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，**确保数据的完整性**。
  - https是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。

#### HTTPS的缺点

- 使页面加载时间延长50%，增加10%-20%的好点
- 影响缓存，郑家数据开销
- 加密范围有限，在黑客攻击、拒绝服务攻击、浏览器劫持方面没什么作用
- SSL整数的信用链体系并不安全
- 费用
- 握手协议费时
- 占用服务器资环高

## 浏览器缓存

### 强制缓存（不需要向浏览器发起请求）判断HTTP首部字段：cache-control，Expires。

- **cache-control中的max-age保存一个相对时间**。例如Cache-Control: max-age = 484200，表示浏览器收到文件后，缓存在484200s内均有效。
- Expires是一个绝对时间，即服务器时间。浏览器检查当前时间，如果还没到失效时间就直接使用缓存文件。但是该方法存在一个问题：服务器时间与客户端时间可能不一致。因此该字段已经很少使用。
- 如果同时存在cache-control和Expires，浏览器总是优先使用cache-control。

### 对比缓存（需要向服务器发送请求）通过HTTP的last-modified，Etag字段进行判断

- **last-modified是第一次请求资源时，服务器返回的字段，表示最后一次更新的时间**。下一次浏览器请求资源时就发送**if-modified-since字段**。服务器用本地Last-modified时间与if-modified-since时间比较，如果不一致则认为缓存已过期并返回新资源给浏览器；如果**时间一致则发送304状态码**，让浏览器继续使用缓存。
- **Etag**：资源的实体标识（哈希字符串），当资源内容更新时，Etag会改变。服务器会判断Etag是否发生变化，如果变化则返回新资源，否则返回304。

## DNS解析

通过域名查找目标文件所在主机的IP地址 查找过程： 查找过程

- **浏览器搜索自己的 DNS 缓存**（维护一张域名与 IP 地址的对应表）；
- 搜索**操作系统中的 DNS 缓存**（维护一张域名与 IP 地址的对应表）；
- 搜索**操作系统的 hosts 文件**（ Windows 环境下，维护一张域名与 IP 地址的对应表）；
- 操作系统将域名发送至 LDNS**（本地区域名服务器**，如果你在学校接入互联网，则 LDNS 服务器就在学校，如果通过电信接入互联网，则 LDNS 服务器就在你当地的电信那里。）LDNS 查询 自己的 DNS 缓存（一般查找成功率在 80% 左右），查找成功则返回结果，失败则发起一个迭代 DNS 解析请求；
  - LDNS 向 Root Name Server （**根域名服务器**，其虽然没有每个域名的的具体信息，但存储了负责每个域，如 com、net、org等的解析的顶级域名服务器的地址）发起请求，此处，Root Name Server 返回 com 域的顶级域名服务器的地址；
  - LDNS 向 com 域的**顶级域名服务器**发起请求，返回 [baidu.com](http://baidu.com/) 域名服务器地址；
  - LDNS 向**[baidu.com](http://baidu.com/) 域名服务器**发起请求，得到 [www.baidu.com](http://www.baidu.com/) 的 IP 地址；
- LDNS 将得到的 IP 地址返回给操作系统，同时自己也将 IP 地址缓存起来；
- 操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来；
- 至此，浏览器已经得到了域名对应的 IP 地址。

### DNS优化

#### DNS缓存

NS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: **浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存**。

#### DNS负载均衡

DNS可以返回一个合适的机器的IP给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，这种过程就是DNS负载均衡，又叫做DNS重定向。

## TCP连接（三次握手）

![image](https://images2015.cnblogs.com/blog/1034346/201703/1034346-20170329145607592-1103856922.png)上图部分标志说明：

（1）ACK：TCP规定，只有当ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1

（2）SYN（SYNchronization）：在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这个是一个连接请求报文。对方若同意建立连接，则响应报文中SYN=1，ACK=1。因此，SYN置1表示这是一个连接请求或连接接受报文。

（3）FIN（finish）：终结的意思，用来释放一个连接。当FIN=1时，表明此报文段的发送方的数据已经发送完毕，并请求释放连接。

#### 三次握手

（1）**第一次握手：建立连接**。客户端发送连接请求报文段，将SYN位置1，序列号seq（sequence number）为x；然后，**客户端进入SYN_SEND状态，等待服务器的确认**。

（2）**第二次握手：服务器收到SYN报文段**服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，ACK位置1，确认号ack（acknowledgement number）为x+1；同时，自己还要发送SYN请求信息，将SYN位置1，序列号seq为y；服务器将上述SYN+ACK报文段一并发送给客户端，**此时服务器进入SYN_RECV状态**

**（3）第三次握手：客户端收到服务器的SYN+ACK报文段**：然后将确认号ack设置为y+1，向服务器发送ACK报文段。这个报文段发送完毕后，**客户端和服务器都进入ESTABLISHED状态，完成TCP三次握手，之后可以开始传数据** ！

## 断开TCP连接（四次挥手）

![image](https://images2015.cnblogs.com/blog/1034346/201703/1034346-20170329153945389-2019926409.png)

- 第一次挥手是浏览器发完数据后，发送FIN请求断开连接。

- 第二次挥手是服务器发送ACK表示同意，如果在这一次服务器也发送FIN请求断开连接似乎也没有不妥，但考虑到服务器可能还有数据要发送，所以服务器发送FIN应该放在第三次挥手中。

- 这样浏览器需要返回ACK表示同意，也就是第四次挥手

  注：

  - 为什么服务器在接到断开请求时不立即同意断开：当服务器收到断开连接的请求时，可能仍然有数据未发送完毕，所有服务器先发送确认信号，等所有数据发送完毕后再同意断开。
  - 第四次握手后，主机发送确认信号后并没有立即断开连接，而是等待了 2 个报文传送周期，原因是：如果第四次握手的确认信息丢失，服务器将会重新发送第三次握手的断开连接的信号，而服务器发觉丢包与重新发送的断开连接到达主机的时间正好为 2 个报文传输周期。

## HTTP请求

- HTTP请求报文是由三部分组成: 请求行, 请求报头和请求正文。

### 请求行

```
Method Request-URL HTTP-Version CRLF

eg: GET index.html HTTP/1.1
```

- 常用的方法有: GET, POST, PUT, DELETE, OPTIONS, HEAD。

### 请求报头

- 请求报头允许客户端向服务器传递请求的附加信息和客户端自身的信息。
- 常见的请求报头有: Accept, Accept-Charset, Accept-Encoding, Accept-Language, Content-Type, Authorization, **Cookie**, User-Agent等。
- Accept用于指定客户端用于接受哪些类型的信息，Accept-Encoding与Accept类似，它用于指定接受的编码方式。Connection设置为Keep-alive用于告诉客户端本次HTTP请求结束之后并不需要关闭TCP连接，这样可以使下次HTTP请求使用相同的TCP通道，节省TCP连接建立的时间。

### 请求正文

当使用POST, PUT等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中。在请求包头中有一些与请求正文相关的信息，例如: 现在的Web应用通常采用Rest架构，请求的数据格式一般为json。这时就需要设置Content-Type: application/json。

### 五层因特尔协议栈

1.应用层(dns,http) DNS解析成IP并发送http请求

2.传输层(tcp,udp) 建立tcp连接（三次握手）

3.网络层(IP,ARP) IP寻址

4.数据链路层(PPP) 封装成帧

5.物理层(利用物理介质传输比特流) 物理传输（然后传输的时候通过双绞线，电磁波等各种介质） **从客户端发出http请求到服务器接收，中间会经过一系列的流程。**

- 从应用层的发送http请求
- 到传输层通过三次握手建立tcp/ip连接
- 再到网络层的ip寻址
- 再到数据链路层的封装成帧
- 最后到物理层的利用物理介质传输。

- ISO七层模型：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层

### http1.0 1.1 2 的区别

#### 长连接与连接

首先看tcp/ip层面的定义：

- 长连接：一个tcp/ip连接上可以连续发送多个数据包，在tcp连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（类似于心跳包）
- 短连接：通信双方有数据交互时，就建立一个tcp连接，数据发送完成后，则断开此tcp连接

#### http1.0,http1.1

- **http1.0中，默认使用的是短连接**，也就是说，浏览器没进行一次http操作，就建立一次连接，任务结束就中断连接，譬如每一个静态资源请求时都是一个单独的连接
- **http1.1起，默认使用长连接**，使用长连接会有这一行Connection: keep-alive，在长连接的情况下，当一个网页打开完成后，客户端和服务端之间用于传输http的tcp连接不会关闭，如果客户端再次访问这个服务器的页面，会继续使用这一条已经建立的连接
- **keep-alive不会永远保持，它有一个持续时间**，一般在服务器中配置（如apache），另外长连接需要客户端和服务器都支持时才有效

#### HTTP2.0

##### HTTP2.0 与http1.1

- **http1.1中，每请求一个资源，都是需要开启一个tcp/ip连接的**，所以对应的结果是，每一个资源对应一个tcp/ip请求，由于tcp/ip本身有并发数限制，所以当资源一多，速度就显著慢下来
- **http2.0中，一个tcp/ip请求可以请求多个资源**，也就是说，只要一次tcp/ip请求，就可以请求若干个资源，分割成更小的帧请求，速度明显提升。

HTTP2.0特性

- 多路复用（一个tcp/ip可以请求多个资源）
- 首部压缩（HTTP头部压缩，减少体积）
- 二进制分帧（在应用层和传输层之间增加二进制分帧层，改进传输性能，实现低延迟和高吞吐量）
- 服务端推送（服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端）
- 请求优先级（如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求。）

## 服务器处理请求并返回HTTP报文

### 通用头部（状态码）

```
Request Url: 请求的web服务器地址
 
Request Method: 请求方式
（Get、POST、OPTIONS、PUT、HEAD、DELETE、CONNECT、TRACE）
 
Status Code: 请求的返回状态码，如200代表成功
 
Remote Address: 请求的远程服务器地址（会转为IP）
```

1xx：指示信息–表示请求已接收，继续处理。

2xx：成功–表示请求已被成功接收、理解、接受。

3xx：重定向–要完成请求必须进行更进一步的操作。

4xx：客户端错误–请求有语法错误或请求无法实现。

5xx：服务器端错误–服务器未能实现合法的请求。

- 平时遇到比较常见的状态码有:200, 204, 301, 302, 304, 400, 401, 403, 404, 422, 500(分别表示什么请自行查找)。

| 状态码 | 状态码英文名称                  | 中文描述                                                     |
| ------ | ------------------------------- | ------------------------------------------------------------ |
| 100    | Continue                        | 继续。[客户端](http://www.dreamdu.com/webbuild/client_vs_server/)应继续其请求 |
| 101    | Switching Protocols             | 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 |
|        |                                 |                                                              |
| 200    | OK                              | 请求成功。一般用于GET与POST请求                              |
| 201    | Created                         | 已创建。成功请求并创建了新的资源                             |
| 202    | Accepted                        | 已接受。已经接受请求，但未处理完成                           |
| 203    | Non-Authoritative Information   | 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 |
| 204    | No Content                      | 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 |
| 205    | Reset Content                   | 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 |
| 206    | Partial Content                 | 部分内容。服务器成功处理了部分GET请求                        |
|        |                                 |                                                              |
| 300    | Multiple Choices                | 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 |
| 301    | Moved Permanently               | 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 |
| 302    | Found                           | 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI |
| 303    | See Other                       | 查看其它地址。与301类似。使用GET和POST请求查看               |
| 304    | Not Modified                    | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 |
| 305    | Use Proxy                       | 使用代理。所请求的资源必须通过代理访问                       |
| 306    | Unused                          | 已经被废弃的HTTP状态码                                       |
| 307    | Temporary Redirect              | 临时重定向。与302类似。使用GET请求重定向                     |
|        |                                 |                                                              |
| 400    | Bad Request                     | 客户端请求的语法错误，服务器无法理解                         |
| 401    | Unauthorized                    | 请求要求用户的身份认证                                       |
| 402    | Payment Required                | 保留，将来使用                                               |
| 403    | Forbidden                       | 服务器理解请求客户端的请求，但是拒绝执行此请求               |
| 404    | Not Found                       | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面 |
| 405    | Method Not Allowed              | 客户端请求中的方法被禁止                                     |
| 406    | Not Acceptable                  | 服务器无法根据客户端请求的内容特性完成请求                   |
| 407    | Proxy Authentication Required   | 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 |
| 408    | Request Time-out                | 服务器等待客户端发送的请求时间过长，超时                     |
| 409    | Conflict                        | 服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突 |
| 410    | Gone                            | 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 |
| 411    | Length Required                 | 服务器无法处理客户端发送的不带Content-Length的请求信息       |
| 412    | Precondition Failed             | 客户端请求信息的先决条件错误                                 |
| 413    | Request Entity Too Large        | 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 |
| 414    | Request-URI Too Large           | 请求的URI过长（URI通常为网址），服务器无法处理               |
| 415    | Unsupported Media Type          | 服务器无法处理请求附带的媒体格式                             |
| 416    | Requested range not satisfiable | 客户端请求的范围无效                                         |
| 417    | Expectation Failed              | 服务器无法满足Expect的请求头信息                             |
|        |                                 |                                                              |
| 500    | Internal Server Error           | 服务器内部错误，无法完成请求                                 |
| 501    | Not Implemented                 | 服务器不支持请求的功能，无法完成请求                         |
| 502    | Bad Gateway                     | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 |
| 503    | Service Unavailable             | 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 |
| 504    | Gateway Time-out                | 充当网关或代理的服务器，未及时从远端服务器获取请求           |
| 505    | HTTP Version not supported      | 服务器不支持请求的HTTP协议的版本，无法完成处理               |

### 响应报头，响应报文

- 常见的响应报头字段有: Server, Connection...。
- 服务器返回给浏览器的文本信息，通常HTML, CSS, JS, 图片等文件就放在这一部分。

# GET,POST,PUT等

**一、HTTP中定义了以下几种请求方法:**

1、GET；2、POST；3、PUT；4、DELETE;
5、HEAD；6、TRACE；7、OPTIONS；

**二、各个方法介绍：**

**1、GET方法：**对这个资源的查操作。

**2、DELETE方法：**对这个资源的删操作。但要注意：客户端无法保证删除操作一定会被执行，因为HTTP规范允许服务器在不通知客

户端的情况下撤销请求。

**3、HEAD方法：**与GET方法的行为很类似，但服务器在响应中只返回实体的主体部分。这就允许客户端在未获取实际资源的情

况下，对资源的首部进行检查，使用HEAD，我们可以更高效的完成以下工作：

在不获取资源的情况下，了解资源的一些信息，比如资源类型；

通过查看响应中的状态码，可以确定资源是否存在；

通过查看首部，测试资源是否被修改；

**4、TRACE方法：**会在目的服务器端发起一个“回环”诊断，我们都知道，客户端在发起一个请求时，这个请求可能要穿过防火墙、代理、网关、或者其它的一些应用程序。这中间的每个节点都可能会修改原始的HTTP请求，TRACE方法允许客户端在最终将请求发送服务器时，它变成了什么样子。由于有一个“回环”诊断，在请求最终到达服务器时，服务器会弹回一条TRACE响应，并在响应主体中携带它收到的原始请求报文的最终模样。这样客户端就可以查看HTTP请求报文在发送的途中，是否被修改过了。

**5、OPTIONS方法：**用于获取当前URL所支持的方法。若请求成功，则它会在HTTP头中包含一个名为“Allow”的头，值是所支持的方法，如“GET, POST”。

**二、方发之间的区别：**

**1、PUT和POST**

PUT和POS都有更改指定URI的语义.但PUT被定义为idempotent的方法，POST则不是.idempotent的方法:如果一个方法重复执行

多次，产生的效果是一样的，那就是idempotent的。也就是说：

PUT请求：如果两个请求相同，后一个请求会把第一个请求覆盖掉。（所以PUT用来改资源）

Post请求：后一个请求不会把第一个请求覆盖掉。（所以Post用来增资源）

**2、get和post**

# **重点**

1、GET参数通过URL传递，POST放在Request body中。

2、GET请求会被浏览器主动cache，而POST不会，除非手动设置。

3、GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。

4、Get 请求中有非 ASCII 字符，会在请求之前进行转码，POST不用，因为POST在Request body中，通过 MIME，也就可以传输非 ASCII 字符。

5、 一般我们在浏览器输入一个网址访问网站都是GET请求

6、HTTP的底层是TCP/IP。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。但是请求的数据量太大对浏览器和服务器都是很大负担。所以业界有了不成文规定，（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。

7、GET产生一个TCP数据包；POST产生两个TCP数据包。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。

8、在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。但并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。

# 常用排序算法

![img](https://uploadfiles.nowcoder.com/images/20200220/1579420_1582183220336_2B316D5B7E8F9ED3A61AD17D2AB8E0FE)

